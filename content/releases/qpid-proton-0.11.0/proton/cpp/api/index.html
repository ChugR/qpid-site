<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>C++ AMQP Protocol Engine API: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">C++ AMQP Protocol Engine API
   &#160;<span id="projectnumber">0.11.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the C++ API for the proton AMQP protocol engine. It allows you to write client and server applications that send and receive AMQP messages.</p>
<p>The best way to start is with the <a class="el" href="tutorial.html">tutorial</a>.</p>
<h2>An overview of the model </h2>
<p>Messages are transferred between connected peers over 'links'. At the sending peer the link is called a sender. At the receiving peer it is called a receiver. Messages are sent by senders and received by receivers. Links may have named 'source' and 'target' addresses (see "sources and targets" below.)</p>
<p>Links are established over sessions. Sessions are established over connections. Connections are (generally) established between two uniquely identified containers. Though a connection can have multiple sessions, often this is not needed. The container API allows you to ignore sessions unless you actually require them.</p>
<p>The sending of a message over a link is called a delivery. The message is the content sent, including all meta-data such as headers and annotations. The delivery is the protocol exchange associated with the transfer of that content.</p>
<p>To indicate that a delivery is complete, either the sender or the receiver 'settles' it. When the other side learns that it has been settled, they will no longer communicate about that delivery. The receiver can also indicate whether they accept or reject the message.</p>
<p>Three different delivery levels or 'guarantees' can be achieved: at-most-once, at-least-once or exactly-once. See below for details.</p>
<h3>Sources and targets</h3>
<p>Every link has two addresses, <em>source</em> and <em>target</em>. The most common pattern for using these addresses is as follows:</p>
<p>When a client creates a <em>receiver</em> link, it sets the <em>source</em> address. This means "I want to receive messages from this source." This is often referred to as "subscribing" to the source. When a client creates a <em>sender</em> link, it sets the <em>target</em> address. This means "I want to send to this target."</p>
<p>In the case of a broker, the source or target usually refers to a queue or topic. In general they can refer to any AMQP-capable node.</p>
<p>In the <em>request-response</em> pattern, a request message carries a <em>reply-to</em> address for the response message. This can be any AMQP address, but it is often useful to create a temporary address for just the response message.</p>
<p>The most common approach is for the client to create a <em>receiver</em> for the response with the <em>dynamic</em> flag set. This asks the server to generate a unique <em>source</em> address automatically and discard it when the link closes. The client uses this "dynamic" source address as the reply-to when it sends the request, and the response is delivered to the client's dynamic receiver.</p>
<p>In the case of a broker a dynamic address usually corresponds to a temporary queue but any AMQP request-response server can use this technique. The <a class="el" href="server_direct_8cpp-example.html">server_direct.cpp</a> example illustrates how to implement a queueless request-response server.</p>
<h2>Commonly used classes </h2>
<p>A brief summary of some of the key classes follows.</p>
<p>The <code><a class="el" href="classproton_1_1container.html">proton::container</a></code> class is the main entry point into the API, allowing connections and links to be established. Applications are structured as one or more event handlers.</p>
<p>The easiest way to implement a handler is to define a subclass of <code><a class="el" href="classproton_1_1messaging__handler.html">proton::messaging_handler</a></code> and over-ride the event handling member functions that interest you.</p>
<p>To send messages, call <code>proton::container::create_sender()</code> to create a <code><a class="el" href="classproton_1_1sender.html" title="A sending link. ">proton::sender</a></code> and then call <code><a class="el" href="classproton_1_1sender.html#aa2db2b7a3082e730358bb0dcbd154ad9" title="Send a message on the link. ">proton::sender::send()</a></code>. This is typically done when the sender is <em>sendable</em>, a condition indicated by the <code><a class="el" href="classproton_1_1messaging__handler.html#ac7fce3d3c61df8d53a00bacad8a9f937">proton::messaging_handler::on_sendable()</a></code> event, to avoid execessive build up of messages.</p>
<p>To receive messages, call <code>proton::container::create_receiver()</code> to create a <code><a class="el" href="classproton_1_1receiver.html" title="A receiving link. ">proton::receiver</a></code>. When messages are recieved the <code><a class="el" href="classproton_1_1messaging__handler.html#aaf6bffc63bf68e3b789dcc5a1f0be849">proton::messaging_handler::on_message()</a></code> event handler function will be called.</p>
<p>Other key classes:</p>
<ul>
<li><a class="el" href="classproton_1_1message.html">proton::message</a> represents an AMQP message, which has a body, headers and other properties.</li>
<li><a class="el" href="classproton_1_1connection.html">proton::connection</a> represents a connection to a remote AMQP endpoint.</li>
<li><a class="el" href="classproton_1_1delivery.html">proton::delivery</a> holds the delivery status of a message.</li>
<li><a class="el" href="classproton_1_1event.html">proton::event</a> carries details of an event.</li>
</ul>
<p>The library provides intuitive default conversions between AMQP and C++ types for message data q, but also allows detailed examination and construction of complex AMQP types. For details on converting between AMQP and C++ data types see the <a class="el" href="encode_decode_8cpp-example.html">encode_decode.cpp</a> example and classes <code><a class="el" href="classproton_1_1encoder.html">proton::encoder</a></code>, <code><a class="el" href="classproton_1_1decoder.html">proton::decoder</a></code> and <code><a class="el" href="classproton_1_1value.html">proton::value</a></code>.</p>
<h2>Delivery Guarantees </h2>
<p>For <em>at-most-once</em>, the sender settles the message as soon as it sends it. If the connection is lost before the message is received by the receiver, the message will not be delivered.</p>
<p>For <em>at-least-once</em>, the receiver accepts and settles the message on receipt. If the connection is lost before the sender is informed of the settlement, then the delivery is considered in-doubt and should be retried. This will ensure it eventually gets delivered (provided of course the connection and link can be reestablished). It may mean that it is delivered multiple times though.</p>
<p>Finally, for <em>exactly-once</em>, the receiver accepts the message but doesn't settle it. The sender settles once it is aware that the receiver accepted it. In this way the receiver retains knowledge of an accepted message until it is sure the sender knows it has been accepted. If the connection is lost before settlement, the receiver informs the sender of all the unsettled deliveries it knows about, and from this the sender can deduce which need to be redelivered. The sender likewise informs the receiver which deliveries it knows about, from which the receiver can deduce which have already been settled. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
