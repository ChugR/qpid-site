<hr>
<h2><a name="introduction"></a>1. Introduction</h2>
<h3><a name="overview"></a>1.1. Overview</h3>
<p>The Dispatch router is an AMQP message router that provides
advanced interconnect capabilities. It allows flexible routing of
messages between any AMQP-enabled endpoints, whether they be clients,
servers, brokers or any other entity that can send or receive standard
AMQP messages.</p>
<p>A messaging client can make a single AMQP connection into a messaging
bus built of Dispatch routers and, over that connection, exchange
messages with one or more message brokers, and at the same time exchange
messages directly with other endpoints without involving a broker at
all.</p>
<p>The router is an intermediary for messages but it is <em>not</em> a broker. It
does not <em>take responsibility for</em> messages. It will, however, propagate
settlement and disposition across a network such that delivery
guarantees are met. In other words: the router network will deliver the
message, possibly via several intermediate routers, <em>and</em> it will route
the acknowledgement of that message by the ultimate receiver back across
the same path. This means that <em>responsibility</em> for the message is
transfered from the original sender to the ultimate receiver <em>as if
they were directly connected</em>. However this is done via a flexible
network that allows highly configurable routing of the message
transparent to both sender and receiver.</p>
<p>There are some patterns where this enables "brokerless messaging"
approaches that are preferable to brokered approaches. In other cases a
broker is essential (in particular where you need the separation of
responsibility and/or the buffering provided by store-and-forward) but a
dispatch network can still be useful to tie brokers and clients together
into patterns that are difficult with a single broker.</p>
<p>For a "brokerless" example, consider the common brokered implementation
of the request-response pattern, a client puts a request on a queue and
then waits for a reply on another queue. In this case the broker can be
a hindrance - the client may want to know immediatly if there is nobody
to serve the request, but typically it can only wait for a timeout to
discover this. With a dispatch network, the client can be informed
immediately if its message cannot be delivered because nobody is
listening. When the client receives acknowledgement of the request it
knows not just that it is sitting on a queue, but that it has actually
been received by the server.</p>
<p>For an exampe of using dispatch to enhance the use of brokers, consider
using an array of brokers to implement a scalable distributed work
queue. A dispatch network can make this appear as a single queue, with
senders publishing to a single address and receivers subscribing to a
single address. The dispatch network can distribute work to any broker
in the array and collect work from any broker for any receiver. Brokers
can be shut down or added without affecting clients. This elegantly
solves the common difficulty of "stuck messages" when implementing this
pattern with brokers alone. If a receiver is connected to a broker that
has no messages, but there are messages on another broker, you have to
somehow transfer them or leave them "stuck". With a dispatch network,
<em>all</em> the receivers are connected to <em>all</em> the brokers. If there is a
message anywhere it can be delivered to any receiver.</p>
<p>The router is meant to be deployed in topologies of multiple routers,
preferably with redundant paths. It uses link-state routing protocols
and algorithms (similar to OSPF or IS-IS from the networking world) to
calculate the best path from every point to every other point and to
recover quickly from failures. It does not need to use clustering for
high availability; rather, it relies on redundant paths to provide
continued connectivity in the face of system or network failure. Because
it never takes responsibility for messages it is effectively stateless.
Messages not delivered to their final destination will not be
acknowledged to the sender and therefore the sender can re-send such
messages if it is disconnected from the network.</p>
<h3><a name="benefits"></a>1.2. Benefits</h3>
<p>Simplifies connectivity</p>
<ul>
<li>
<p>
An endpoint can do all of its messaging through a single transport
connection
</p>
</li>
<li>
<p>
Avoid opening holes in firewalls for incoming connections
</p>
</li>
</ul>
<p>Provides messaging connectivity where there is no TCP/IP connectivity</p>
<ul>
<li>
<p>
A server or broker can be in a private IP network (behind a NAT
firewall) and be accessible by messaging endpoints in other networks
(learn more).
</p>
</li>
</ul>
<p>Simplifies reliability</p>
<ul>
<li>
<p>
Reliability and availability are provided using redundant topology,
not server clustering
</p>
</li>
<li>
<p>
Reliable end-to-end messaging without persistent stores
</p>
</li>
<li>
<p>
Use a message broker only when you need store-and-forward semantics
</p>
</li>
</ul>
<h3><a name="features"></a>1.3. Features</h3>
<ul>
<li>
<p>
Can be deployed stand-alone or in a network of routers
</p>
<ul>
<li>
<p>
Supports arbitrary network topology - no restrictions on redundancy
</p>
<ul>
<li>
<p>
Automatic route computation - adjusts quickly to changes in topology
</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
Provides remote access to brokers or other AMQP servers
</p>
</li>
<li>
<p>
Security
</p>
</li>
</ul>
<hr>
<h2><a name="using-qpid-dispatch"></a>2. Using Qpid Dispatch</h2>
<h3><a name="configuration"></a>2.1. Configuration</h3>
<p>The default configuration file is installed in
<em>/usr/local/etc/qpid-dispatch/qdrouterd.conf</em>. This configuration file will
cause the router to run in standalone mode, listening on the standard
AMQP port (5672). Dispatch Router looks for the configuration file in
the installed location by default. If you wish to use a different path,
the "-c" command line option will instruct Dispatch Router as to which
configuration to load.</p>
<p>To run the router, invoke the executable: <code>qdrouterd [-c my-config-file]</code></p>
<p>For more details of the configuration file see the <em>qdrouterd.conf(5)</em> man
page.</p>
<h3><a name="tools"></a>2.2. Tools</h3>
<h4><a name="qdstat"></a>2.2.1. qdstat</h4>
<p><em>qdstat</em> is a command line tool that lets you view the status of a
Dispatch Router. The following options are useful for seeing what the
router is doing:</p>
<div>
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<thead>
<tr>
<th align="left" width="17%" valign="top"><em>Option</em> </th>
<th align="left" width="83%" valign="top"><em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" width="17%" valign="top"><p>-l</p></td>
<td align="left" width="83%" valign="top"><p>Print a list of AMQP links attached to the router. Links are
unidirectional. Outgoing links are usually associated with a
subscription address. The tool distinguishes between <em>endpoint</em> links
and <em>router</em> links. Endpoint links are attached to clients using the
router. Router links are attached to other routers in a network of
routbers.</p></td>
</tr>
<tr>
<td align="left" width="17%" valign="top"><p>-a</p></td>
<td align="left" width="83%" valign="top"><p>Print a list of addresses known to the router.</p></td>
</tr>
<tr>
<td align="left" width="17%" valign="top"><p>-n</p></td>
<td align="left" width="83%" valign="top"><p>Print a list of known routers in the network.</p></td>
</tr>
<tr>
<td align="left" width="17%" valign="top"><p>-c</p></td>
<td align="left" width="83%" valign="top"><p>Print a list of connections to the router.</p></td>
</tr>
<tr>
<td align="left" width="17%" valign="top"><p>--autolinks</p></td>
<td align="left" width="83%" valign="top"><p>Print a list of configured auto-links.</p></td>
</tr>
<tr>
<td align="left" width="17%" valign="top"><p>--linkroutes</p></td>
<td align="left" width="83%" valign="top"><p>Print a list of configures link-routes.</p></td>
</tr>
</tbody>
</table>
</div>
<p>For complete details see the <em>qdstat(8)</em> man page and the output of
<code>qdstat --help</code>.</p>
<h4><a name="qdmanage"></a>2.2.2. qdmanage</h4>
<p><em>qdmanage</em> is a general-purpose AMQP management client that allows you
to not only view but modify the configuration of a running dispatch
router.</p>
<p>For example you can query all the connection entities in the router:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ qdmanage query --type connection</code></pre>
</td></tr></table>
<p>To enable logging debug and higher level messages by default:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ qdmanage update log/DEFAULT enable=debug+</code></pre>
</td></tr></table>
<p>In fact, everything that can be configured in the configuration file can
also be created in a running router via management. For example to
create a new listener in a running router:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ qdmanage create type=listener port=5555</code></pre>
</td></tr></table>
<p>Now you can connect to port 5555, for exampple:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ qdmanage query -b localhost:5555 --type listener</code></pre>
</td></tr></table>
<p>For complete details see the <em>qdmanage(8)</em> man page and the output of
<code>qdmanage --help</code>. Also for details of what can be configured see the
<em>qdrouterd.conf(5)</em> man page.</p>
<h3><a name="basic-usage-and-examples"></a>2.3. Basic Usage and Examples</h3>
<h4><a name="standalone-and-interior-modes"></a>2.3.1. Standalone and Interior Modes</h4>
<p>The router can operate stand-alone or as a node in a network of routers.
The mode is configured in the <em>router</em> section of the configuration
file. In stand-alone mode, the router does not attempt to collaborate
with any other routers and only routes messages among directly connected
endpoints.</p>
<p>If your router is running in stand-alone mode, <em>qdstat -a</em> will look
like the following:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ qdstat -a
Router Addresses
  class   addr                   phs  distrib  in-proc  local  remote  cntnr  in  out  thru  to-proc  from-proc
  ===============================================================================================================
  local   $_management_internal       closest  1        0      0       0      0   0    0     0        0
  local   $displayname                closest  1        0      0       0      0   0    0     0        0
  mobile  $management            0    closest  1        0      0       0      1   0    0     1        0
  local   $management                 closest  1        0      0       0      0   0    0     0        0
  local   temp.1GThUllfR7N+BDP        closest  0        1      0       0      0   0    0     0        0</code></pre>
</td></tr></table>
<p>Note that there are a number of known addresses. <em>$management</em> is the
address of the router&#8217;s embedded management agent.
<em>temp.1GThUllfR7N+BDP</em> is the temporary reply-to address of the <em>qdstat</em>
client making requests to the agent.</p>
<p>If you change the mode to interior and restart the processs, the same
command will yield additional addresses which are used for inter-router
communication:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ qdstat -a
Router Addresses
  class   addr                   phs  distrib    in-proc  local  remote  cntnr  in  out  thru  to-proc  from-proc
  =================================================================================================================
  local   $_management_internal       closest    1        0      0       0      0   0    0     0        0
  local   $displayname                closest    1        0      0       0      0   0    0     0        0
  mobile  $management            0    closest    1        0      0       0      1   0    0     1        0
  local   $management                 closest    1        0      0       0      0   0    0     0        0
  local   qdhello                     flood      1        0      0       0      0   0    0     0        10
  local   qdrouter                    flood      1        0      0       0      0   0    0     0        0
  topo    qdrouter                    flood      1        0      0       0      0   0    0     0        1
  local   qdrouter.ma                 multicast  1        0      0       0      0   0    0     0        0
  topo    qdrouter.ma                 multicast  1        0      0       0      0   0    0     0        0
  local   temp.wfx54+zf+YWQF3T        closest    0        1      0       0      0   0    0     0        0</code></pre>
</td></tr></table>
<h4><a name="mobile-subscribers"></a>2.3.2. Mobile Subscribers</h4>
<p>The term "mobile subscriber" simply refers to the fact that a client may
connect to the router and subscribe to an address to receive messages
sent to that address. No matter where in the network the subscriber
attaches, the messages will be routed to the appropriate destination.</p>
<p>To illustrate a subscription on a stand-alone router, you can use the
examples that are provided with Qpid Proton. Using the <em>simple_recv.py</em>
example receiver:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ python ./simple_recv.py -a 127.0.0.1/my-address</code></pre>
</td></tr></table>
<p>This command creates a receiving link subscribed to the specified
address. To verify the subscription:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ qdstat -a
Router Addresses
  class   addr                   phs  distrib  in-proc  local  remote  cntnr  in  out  thru  to-proc  from-proc
  ===============================================================================================================
  local   $_management_internal       closest  1        0      0       0      0   0    0     0        0
  local   $displayname                closest  1        0      0       0      0   0    0     0        0
  mobile  $management            0    closest  1        0      0       0      2   0    0     2        0
  local   $management                 closest  1        0      0       0      0   0    0     0        0
  mobile  my-address             0    closest  0        1      0       0      0   0    0     0        0
  local   temp.75_d2X23x_KOT51        closest  0        1      0       0      0   0    0     0        0</code></pre>
</td></tr></table>
<p>You can then, in a separate command window, run a sender to produce
messages to that address:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ python ./simple_send.py -a 127.0.0.1/my-address</code></pre>
</td></tr></table>
<h4><a name="dynamic-reply-to"></a>2.3.3. Dynamic Reply-To</h4>
<p>Dynamic reply-to can be used to obtain a reply-to address that routes
back to a client&#8217;s receiving link regardless of how many hops it has to
take to get there. To illustrate this feature, see below a simple
program (written in C++ against the qpid::messaging API) that queries
the management agent of the attached router for a list of other known
routers' management addresses.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>#include &lt;qpid/messaging/Address.h&gt;
#include &lt;qpid/messaging/Connection.h&gt;
#include &lt;qpid/messaging/Message.h&gt;
#include &lt;qpid/messaging/Receiver.h&gt;
#include &lt;qpid/messaging/Sender.h&gt;
#include &lt;qpid/messaging/Session.h&gt;

using namespace qpid::messaging;
using namespace qpid::types;

using std::stringstream;
using std::string;

int main() {
    const char* url = "amqp:tcp:127.0.0.1:5672";
    std::string connectionOptions = "{protocol:amqp1.0}";

    Connection connection(url, connectionOptions);
    connection.open();
    Session session = connection.createSession();
    Sender sender = session.createSender("mgmt");

    // create reply receiver and get the reply-to address
    Receiver receiver = session.createReceiver("#");
    Address responseAddress = receiver.getAddress();

    Message request;
    request.setReplyTo(responseAddress);
    request.setProperty("x-amqp-to", "amqp:/_local/$management");
    request.setProperty("operation", "DISCOVER-MGMT-NODES");
    request.setProperty("type", "org.amqp.management");
    request.setProperty("name, "self");

    sender.send(request);
    Message response = receiver.fetch();
    Variant content(response.getContentObject());
    std::cout &lt;&lt; "Response: " &lt;&lt; content &lt;&lt; std::endl &lt;&lt; std::endl;

    connection.close();
}</code></pre>
</td></tr></table>
<p>The equivalent program written in Python against the Proton Messenger
API:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>from proton import Messenger, Message

def main():
    host = "0.0.0.0:5672"

    messenger = Messenger()
    messenger.start()
    messenger.route("amqp:/*", "amqp://%s/$1" % host)
    reply_subscription = messenger.subscribe("amqp:/#")
    reply_address = reply_subscription.address

    request  = Message()
    response = Message()

    request.address = "amqp:/_local/$management"
    request.reply_to = reply_address
    request.properties = {u'operation' : u'DISCOVER-MGMT-NODES',
                          u'type'      : u'org.amqp.management',
                          u'name'      : u'self'}

    messenger.put(request)
    messenger.send()
    messenger.recv()
    messenger.get(response)

    print "Response: %r" % response.body

    messenger.stop()

main()</code></pre>
</td></tr></table>
<h3><a name="link-routing"></a>2.4. Link Routing</h3>
<p>This feature was introduced in Qpid Dispatch 0.4. This feature was
significantly updated in Qpid Dispatch 0.6.</p>
<p>Link-routing is an alternative strategy for routing messages across a
network of routers. With the existing message-routing strategy, each
router makes a routing decision on a per-message basis when the message
is delivered. Link-routing is different because it makes routing
decisions when link-attach frames arrive. A link is effectively chained
across the network of routers from the establishing node to the
destination node. Once the link is established, the transfer of message
deliveries, flow frames, and dispositions is performed across the routed
link.</p>
<p>The main benefit to link-routing is that endpoints can use the full link
protocol to interact with other endpoints in far-flung parts of the
network.  For example, a client can establish a receiver across the
network to a queue on a remote broker and use link credit to control
the flow of messages from the broker.  Similarly, a receiver can
establish a link to a topic on a remote broker using a server-side
filter.</p>
<p>Why would one want to do this?  One reason is to provide client
isolation.  A network like the following can be deployed:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>                        Public Network
                       +-----------------+
                       |      +-----+    |
                       | B1   | Rp  |    |
                       |      +/--\-+    |
                       |      /    \     |
                       |     /      \    |
                       +----/--------\---+
                           /          \
                          /            \
                         /              \
         Private Net A  /                \ Private Net B
        +--------------/--+           +---\-------------+
        |         +---/-+ |           | +--\--+         |
        |  B2     | Ra  | |           | | Rb  |   C1    |
        |         +-----+ |           | +-----+         |
        |                 |           |                 |
        |                 |           |                 |
        +-----------------+           +-----------------+</code></pre>
</td></tr></table>
<p>The clients in Private Net B can be constrained (by firewall policy)
to only connect to the Router in their own network.  Using
link-routing, these clients can access queues, topics, and other AMQP
services that are in the Public Network or even in Private Net A.</p>
<p>For example, The router Ra can be configured to expose queues in
broker B2 to the network.  Client C1 can then establish a connection
to Rb, the local router, open a subscribing link to "b2.event-queue",
and receive messages stored on that queue in broker B2.</p>
<p>C1 is unable to create a TCP/IP connection to B1 because of its
isolation (and because B2 is itself in a private network). However, with
link routing, C1 can interact with B2 using the AMQP link protocol.</p>
<p>Note that in this case, neither C1 nor B2 have been modified in any way
and neither need be aware of the fact that there is a message-router
network between them.</p>
<h4><a name="link-routing-configuration"></a>2.4.1. Configuration</h4>
<p>Starting with the configured topology shown above, how is link-routing
configured to support the example described above?</p>
<p>First, router Ra needs to be told how to make a connection to the broker
B2:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>connector {
    name: broker
    role: route-container
    host: &lt;B2-url&gt;
    port: &lt;B2-port&gt;
    saslMechanisms: ANONYMOUS
}</code></pre>
</td></tr></table>
<p>This <em>route-container</em> connector tells the router how to connect to an
external AMQP container when it is needed. The name "broker" will be
used later to refer to this connection.</p>
<p>Now, the router must be configured to route certain addresses to B2:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>linkRoute {
    prefix: b2
    dir: in
    connection: broker
}

linkRoute {
    prefix: b2
    dir: out
    connection: broker
}</code></pre>
</td></tr></table>
<p>The linkRoute tells router Ra that any sender or receiver that is
attached with a target or source (respectively) whos address begins with
"b2", should be routed to the broker B2 (via the route-container
connector).</p>
<p>Note that receiving and sending links are configured and routed
separately. This allows configuration of link routes for listeners only
or senders only. A direction of "in" matches client senders (i.e. links
that carry messages inbound to the router network). Direction "out"
matches client receivers.</p>
<p>Examples of addresses that "begin with <em>b2</em>" include:</p>
<ul>
<li>
<p>
b2
</p>
</li>
<li>
<p>
b2.queues
</p>
</li>
<li>
<p>
b2.queues.app1
</p>
</li>
</ul>
<p>When the route-container connector is configured, router Ra establishes
a connection to the broker. Once the connection is open, Ra tells the
other routers (Rp and Rb) that it is a valid destination for link-routes
to the "b2" prefix. This means that sender or receiver links attached to
Rb or Rp will be routed via the shortest path to Ra where they are then
routed outbound to the broker B2.</p>
<p>On Rp and Rb, it is advisable to add the identical configuration. It is
permissible for a linkRoute configuration to reference a connection that
does not exist.</p>
<p>This configuration tells the routers that link-routing is intended to be
available for targets and sources starting with "b2". This is important
because it is possible that B2 might be unavailable or shut off. If B2
is unreachable, Ra will not advertize itself as a destination for "b2"
and the other routers might never know that "b2" was intended for
link-routing.</p>
<p>The above configuration allows Rb and Rp to reject attaches that should
be routed to B2 with an error message that indicates that there is no
route available to the destination.</p>
<h3><a name="indirect-waypoints-and-auto-links"></a>2.5. Indirect Waypoints and Auto-Links</h3>
<p>This feature was introduced in Qpid Dispatch 0.6. It is a significant
improvement on an earlier somewhat experimental feature called
Waypoints.</p>
<p>Auto-link is a feature of Qpid Dispatch Router that enables a router to
actively attach a link to a node on an external AMQP container. The
obvious application for this feature is to route messages through a
queue on a broker, but other applications are possible as well.</p>
<p>An auto-link manages the lifecycle of one AMQP link. If messages are to
be routed to and from a queue on a broker, then two auto-links are
needed: one for sending messages to the queue and another for receiving
messages from the queue. The container to which an auto-link attempts to
attach may be identified in one of two ways:</p>
<blockquote>
<ul>
<li>
<p>
The name of the connector/listener that resulted in the connection of
the container, or
</p>
</li>
<li>
<p>
The AMQP container-id of the remote container.
</p>
</li>
</ul>
<p align="right">
</p>
</blockquote>
<h4><a name="queue-waypoint-example"></a>2.5.1. Queue Waypoint Example</h4>
<p>Here is an example configuration for routing messages deliveries through
a pair of queues on a broker:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>connector {
    name: broker
    role: route-container
    host: &lt;hostname&gt;
    port: &lt;port&gt;
    saslMechanisms: ANONYMOUS
}

address {
    prefix: queue
    waypoint: yes
}

autoLink {
    addr: queue.first
    dir: in
    connection: broker
}

autoLink {
    addr: queue.first
    dir: out
    connection: broker
}

autoLink {
    addr: queue.second
    dir: in
    connection: broker
}

autoLink {
    addr: queue.second
    dir: out
    connection: broker
}</code></pre>
</td></tr></table>
<p>The <code>address</code> entity identifies a namespace <em>queue.</em> that will be used
for routing messages through queues via autolinks. The four <code>autoLink</code> entities
identify the head and tail of two queues on the broker that will be connected
via auto-links.</p>
<p>If there is no broker connected, the auto-links shall remain
<em>inactive</em>. This can be observed by using the <code>qdstat</code> tool:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ qdstat --autolinks
AutoLinks
  addr          dir  phase  link  status    lastErr
  ===================================================
  queue.first   in   1            inactive
  queue.first   out  0            inactive
  queue.second  in   1            inactive
  queue.second  out  0            inactive</code></pre>
</td></tr></table>
<p>If a broker comes online with a queue called <em>queue.first</em>, the
auto-links will attempt to activate:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ qdstat --autolinks
AutoLinks
  addr          dir  phase  link  status  lastErr
  ======================================================================
  queue.first   in   1      6     active
  queue.first   out  0      7     active
  queue.second  in   1            failed  Node not found: queue.second
  queue.second  out  0            failed  Node not found: queue.second</code></pre>
</td></tr></table>
<p>Note that two of the auto-links are in <em>failed</em> state because the queue
does not exist on the broker.</p>
<p>If we now use the Qpid Proton example application <code>simple_send.py</code> to send
three messages to <em>queue.first</em> via the router:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ python simple_send.py -a 127.0.0.1/queue.first -m3
all messages confirmed</code></pre>
</td></tr></table>
<p>and then look at the address statistics on the router:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ qdstat -a
Router Addresses
  class   addr           phs  distrib   in-proc  local  remote  cntnr  in  out  thru  to-proc  from-proc
  ========================================================================================================
  mobile  queue.first    1    balanced  0        0      0       0      0   0    0     0        0
  mobile  queue.first    0    balanced  0        1      0       0      3   3    0     0        0</code></pre>
</td></tr></table>
<p>we see that <em>queue.first</em> appears twice in the list of addresses. The
<code>phs</code>, or phase column shows that there are two phases for the
address. Phase <em>0</em> is for routing message deliveries from producers to
the tail of the queue (the <code>out</code> auto-link associated with the queue).
Phase 1 is for routing deliveries from the head of the queue to
subscribed consumers.</p>
<p>Note that three deliveries have been counted in the "in" and "out"
columns for phase <em>0</em>. The "in" column represents the three messages
that arrived from <code>simple_send.py</code> and the <code>out</code> column represents the three
deliveries to the queue on the broker.</p>
<p>If we now use <code>simple_recv.py</code> to receive three messages from this address:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ python simple_recv.py -a 127.0.0.1:5672/queue.first -m3
{u'sequence': int32(1)}
{u'sequence': int32(2)}
{u'sequence': int32(3)}</code></pre>
</td></tr></table>
<p>We receive the three queued messages. Looking at the addresses again, we
see that phase 1 was used to deliver those messages from the queue to
the consumer.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>$ qdstat -a
Router Addresses
  class   addr           phs  distrib   in-proc  local  remote  cntnr  in  out  thru  to-proc  from-proc
  ========================================================================================================
  mobile  queue.first    1    balanced  0        0      0       0      3   3    0     0        0
  mobile  queue.first    0    balanced  0        1      0       0      3   3    0     0        0</code></pre>
</td></tr></table>
<p>Note that even in a multi-router network, and with multiple producers
and consumers for <em>queue.first</em>, all deliveries will be routed through
the queue on the connected broker.</p>
<h4><a name="sharded-queue-example"></a>2.5.2. Sharded Queue Example</h4>
<p>Here is an extension of the above example to illustrate how Qpid
Dispatch Router can be used to create a distributed queue in which
multiple brokers share the message-queueing load.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>connector {
    name: broker1
    role: route-container
    host: &lt;hostname&gt;
    port: &lt;port&gt;
    saslMechanisms: ANONYMOUS
}

connector {
    name: broker2
    role: route-container
    host: &lt;hostname&gt;
    port: &lt;port&gt;
    saslMechanisms: ANONYMOUS
}

address {
    prefix: queue
    waypoint: yes
}

autoLink {
    addr: queue.first
    dir: in
    connection: broker1
}

autoLink {
    addr: queue.first
    dir: out
    connection: broker1
}

autoLink {
    addr: queue.first
    dir: in
    connection: broker2
}

autoLink {
    addr: queue.first
    dir: out
    connection: broker2
}</code></pre>
</td></tr></table>
<p>In the above configuration, there are two instances of <em>queue.first</em> on
brokers 1 and 2. Message traffic from producers to address <em>queue.first</em>
shall be balanced between the two instance and messages from the queues
shall be balanced across the collection of subscribers to the same
address.</p>
<h4><a name="dynamically-adding-shards"></a>2.5.3. Dynamically Adding Shards</h4>
<p>Since configurable entities in the router can also be accessed via the
management protocol, we can remotely add a shard to the above example
using <code>qdmanage</code>:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>qdmanage create --type org.apache.qpid.dispatch.connector host=&lt;host&gt; port=&lt;port&gt; name=broker3
qdmanage create --type org.apache.qpid.dispatch.router.config.autoLink addr=queue.first dir=in connection=broker3
qdmanage create --type org.apache.qpid.dispatch.router.config.autoLink addr=queue.first dir=out connection=broker3</code></pre>
</td></tr></table>
<hr>
<h2><a name="technical-details-and-specifications"></a>3. Technical Details and Specifications</h2>
<h3><a name="client-compatibility"></a>3.1. Client Compatibility</h3>
<p>Dispatch Router should, in theory, work with any client that is
compatible with AMQP 1.0. The following clients have been tested:</p>
<div>
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<thead>
<tr>
<th align="left" width="22%" valign="top"><em>Client</em> </th>
<th align="left" width="78%" valign="top"><em>Notes</em></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" width="22%" valign="top"><p>qpid::messaging</p></td>
<td align="left" width="78%" valign="top"><p>The Qpid messaging clients work with Dispatch Router
as long as they are configured to use the 1.0 version of the protocol.
To enable AMQP 1.0 in the C++ client, use the {protocol:amqp1.0}
connection option.</p></td>
</tr>
<tr>
<td align="left" width="22%" valign="top"><p>Proton Reactor</p></td>
<td align="left" width="78%" valign="top"><p>The Proton Reactor API is compatible with Dispatch
Router.</p></td>
</tr>
<tr>
<td align="left" width="22%" valign="top"><p>Proton Messenger</p></td>
<td align="left" width="78%" valign="top"><p>Messenger works with Dispatch Router.</p></td>
</tr>
</tbody>
</table>
</div>
<h3><a name="addressing"></a>3.2. Addressing</h3>
<p>AMQP addresses are used to control the flow of messages across a network
of routers. Addresses are used in a number of different places in the
AMQP 1.0 protocol. They can be used in a specific message in the <code>to</code>
and <code>reply-to</code> fields of a message&#8217;s properties. They are also used
during the creation of links in the <code>address</code> field of a <code>source</code> or
a <code>target</code>.</p>
<p>Addresses designate various kinds of entities in a messaging network:</p>
<ul>
<li>
<p>
Endpoint processes that consume data or offer a service
</p>
</li>
<li>
<p>
Topics that match multiple consumers to multiple producers
</p>
</li>
<li>
<p>
Entities within a messaging broker:
</p>
<ul>
<li>
<p>
Queues
</p>
</li>
<li>
<p>
Durable Topics
</p>
</li>
<li>
<p>
Exchanges
</p>
</li>
</ul>
</li>
</ul>
<p>The syntax of an AMQP address is opaque as far as the router network is
concerned. A syntactical structure may be used by the administrator that
creates addresses, but the router treats them as opaque strings. Routers
consider addresses to be mobile such that any address may be directly
connected to any router in a network and may move around the topology.
In cases where messages are broadcast to or balanced across multiple
consumers, an address may be connected to multiple routers in the
network.</p>
<p>Addresses have semantics associated with them. When an address is
created in the network, it is assigned a set of semantics (and access
rules) during a process called provisioning. The semantics of an address
control how routers behave when they see the address being used.</p>
<p>Address semantics include the following considerations:</p>
<ul>
<li>
<p>
<em>Routing pattern</em> - direct, multicast, balanced
</p>
</li>
<li>
<p>
<em>Undeliverable action</em> - drop, hold and retry, redirect
</p>
</li>
<li>
<p>
<em>Reliability</em> - N destinations, etc.
</p>
</li>
</ul>
<h4><a name="routing-patterns"></a>3.2.1. Routing patterns</h4>
<p>Routing patterns constrain the paths that a message can take across a
network.</p>
<div>
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<thead>
<tr>
<th align="left" width="18%" valign="top"><em>Pattern</em> </th>
<th align="left" width="82%" valign="top"><em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" width="18%" valign="top"><p><em>Direct</em></p></td>
<td align="left" width="82%" valign="top"><p>Direct routing allows for only one consumer to use an address
at a time. Messages (or links) follow the lowest cost path across the
network from the sender to the one receiver.</p></td>
</tr>
<tr>
<td align="left" width="18%" valign="top"><p><em>Multicast</em></p></td>
<td align="left" width="82%" valign="top"><p>Multicast routing allows multiple consumers to use the
same address at the same time. Messages are routed such that each
consumer receives a copy of the message.</p></td>
</tr>
<tr>
<td align="left" width="18%" valign="top"><p><em>Balanced</em></p></td>
<td align="left" width="82%" valign="top"><p>Balanced routing also allows multiple consumers to use the
same address. In this case, messages are routed to exactly one of the
consumers, and the network attempts to balance the traffic load across
the set of consumers using the same address.</p></td>
</tr>
</tbody>
</table>
</div>
<h4><a name="routing-mechanisms"></a>3.2.2. Routing mechanisms</h4>
<p>The fact that addresses can be used in different ways suggests that
message routing can be accomplished in different ways. Before going into
the specifics of the different routing mechanisms, it would be good to
first define what is meant by the term <em>routing</em>:</p>
<blockquote>
<p>In a network built of multiple routers connected by connections (i.e.,
nodes and edges in a graph), <em>routing</em> determines which connection to
use to send a message directly to its destination or one step closer to
its destination.</p>
<p align="right">
</p>
</blockquote>
<p>Each router serves as the terminus of a collection of incoming and
outgoing links. The links either connect directly to endpoints that
produce and consume messages, or they connect to other routers in the
network along previously established connections.</p>
<h5><a name="message-routing"></a>Message routing</h5>
<p>Message routing occurs upon delivery of a message and is done based on
the address in the message&#8217;s <code>to</code> field.</p>
<p>When a delivery arrives on an incoming link, the router extracts the
address from the delivered message&#8217;s <code>to</code> field and looks the address up
in its routing table. The lookup results in zero or more outgoing links
onto which the message shall be resent.</p>
<div>
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<thead>
<tr>
<th align="left" width="20%" valign="top"><em>Delivery</em> </th>
<th align="left" width="80%" valign="top"><em>Handling</em></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" width="20%" valign="top"><p><em>pre-settled</em></p></td>
<td align="left" width="80%" valign="top"><p>If the arriving delivery is pre-settled (i.e., fire and
forget), the incoming delivery shall be settled by the router, and the
outgoing deliveries shall also be pre-settled. In other words, the
pre-settled nature of the message delivery is propagated across the
network to the message&#8217;s destination.</p></td>
</tr>
<tr>
<td align="left" width="20%" valign="top"><p><em>unsettled</em></p></td>
<td align="left" width="80%" valign="top"><p>Unsettled delivery is also propagated across the network.
Because unsettled delivery records cannot be discarded, the router
tracks the incoming deliveries and keeps the association of the incoming
deliveries to the resulting outgoing deliveries. This kept association
allows the router to continue to propagate changes in delivery state
(settlement and disposition) back and forth along the path which the
message traveled.</p></td>
</tr>
</tbody>
</table>
</div>
<h3><a name="amqp-mapping"></a>3.3. AMQP Mapping</h3>
<p>Dispatch Router is an AMQP router and as such, it provides extensions,
code-points, and semantics for routing over AMQP. This page documents the
details of Dispatch Router&#8217;s use of AMQP.</p>
<h4><a name="message-annotations"></a>3.3.1. Message Annotations</h4>
<p>The following Message Annotation fields are defined by Dispatch Router:</p>
<div>
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<thead>
<tr>
<th align="left" width="23%" valign="top"><em>Field</em> </th>
<th align="left" width="19%" valign="top"><em>Type</em> </th>
<th align="left" width="58%" valign="top"><em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" width="23%" valign="top"><p>x-opt-qd.ingress</p></td>
<td align="left" width="19%" valign="top"><p>string</p></td>
<td align="left" width="58%" valign="top"><p>The identity of the ingress router for a
message-routed message. The ingress router is the first router
encountered by a transiting message. The router will, if this field is
present, leave it unaltered. If the field is not present, the router
shall insert the field with its own identity.</p></td>
</tr>
<tr>
<td align="left" width="23%" valign="top"><p>x-opt-qd.trace</p></td>
<td align="left" width="19%" valign="top"><p>list of string</p></td>
<td align="left" width="58%" valign="top"><p>The list of routers through which this
message-routed message has transited. If this field is not present, the
router shall do nothing. If the field is present, the router shall
append its own identity to the end of the list.</p></td>
</tr>
<tr>
<td align="left" width="23%" valign="top"><p>x-opt-qd.to</p></td>
<td align="left" width="19%" valign="top"><p>string</p></td>
<td align="left" width="58%" valign="top"><p>To-Override for message-routed messages. If this
field is present, the address in this field shall be used for routing in
lieu of the <em>to</em> field in the message properties. A router may append,
remove, or modify this annotation field depending on the policy in place
for routing the message.</p></td>
</tr>
<tr>
<td align="left" width="23%" valign="top"><p>x-opt-qd.phase</p></td>
<td align="left" width="19%" valign="top"><p>integer</p></td>
<td align="left" width="58%" valign="top"><p>The address-phase, if not zero, for messages
flowing between routers.</p></td>
</tr>
</tbody>
</table>
</div>
<h4><a name="sourcetarget-capabilities"></a>3.3.2. Source/Target Capabilities</h4>
<p>The following Capability values are used in Sources and Targets.</p>
<div>
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<thead>
<tr>
<th align="left" width="19%" valign="top"><em>Capability</em> </th>
<th align="left" width="81%" valign="top"><em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" width="19%" valign="top"><p>qd.router</p></td>
<td align="left" width="81%" valign="top"><p>This capability is added to sources and targets that are
used for inter-router message exchange. This capability denotes a link
used for router-control messages flowing between routers.</p></td>
</tr>
<tr>
<td align="left" width="19%" valign="top"><p>qd.router-data</p></td>
<td align="left" width="81%" valign="top"><p>This capability is added to sources and targets that
are used for inter-router message exchange. This capability denotes a
link used for user messages being message-routed across an inter-router
connection.</p></td>
</tr>
</tbody>
</table>
</div>
<h4><a name="dynamic-node-properties"></a>3.3.3. Dynamic-Node-Properties</h4>
<p>The following dynamic-node-properties are used by Dispatch in Sources.</p>
<div>
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<thead>
<tr>
<th align="left" width="23%" valign="top"><em>Property</em> </th>
<th align="left" width="77%" valign="top"><em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" width="23%" valign="top"><p>x-opt-qd.address</p></td>
<td align="left" width="77%" valign="top"><p>The node address describing the destination desired
for a dynamic source. If this is absent, the router will terminate any
dynamic receivers. If this address is present, the router will use the
address to route the dynamic link attach to the proper destination
container.</p></td>
</tr>
</tbody>
</table>
</div>
<h4><a name="addresses-and-address-formats"></a>3.3.4. Addresses and Address Formats</h4>
<p>The following AMQP addresses and address patterns are used within
Dispatch Router.</p>
<h5><a name="address-patterns"></a>Address Patterns</h5>
<div>
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<thead>
<tr>
<th align="left" width="38%" valign="top"><em>Pattern</em> </th>
<th align="left" width="62%" valign="top"><em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" width="38%" valign="top"><p><code>_local/&lt;addr&gt;</code></p></td>
<td align="left" width="62%" valign="top"><p>An address that references a locally attached endpoint.
Messages using this address pattern shall not be routed over more than
one link.</p></td>
</tr>
<tr>
<td align="left" width="38%" valign="top"><p><code>_topo/0/&lt;router&gt;/&lt;addr&gt;</code></p></td>
<td align="left" width="62%" valign="top"><p>An address that references an endpoint attached to a specific router
node in the network topology. Messages with addresses that follow this
pattern shall be routed along the shortest path to the specified router.
Note that addresses of this form are a-priori routable in that the
address itself contains enough information to route the message to its
destination.</p>
<p>The <em>0</em> component immediately preceding the router-id is a placeholder
for an <em>area</em> which may be used in the future if area routing is
implemented.</p></td>
</tr>
<tr>
<td align="left" width="38%" valign="top"><p><code>&lt;addr&gt;</code></p></td>
<td align="left" width="62%" valign="top"><p>A mobile address. An address of this format represents an
endpoint or a set of distinct endpoints that are attached to the network
in arbitrary locations. It is the responsibility of the router network
to determine which router nodes are valid destinations for mobile
addresses.</p></td>
</tr>
</tbody>
</table>
</div>
<h5><a name="supported-addresses"></a>Supported Addresses</h5>
<div>
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<thead>
<tr>
<th align="left" width="36%" valign="top"><em>Address</em> </th>
<th align="left" width="64%" valign="top"><em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" width="36%" valign="top"><p><code>$management</code></p></td>
<td align="left" width="64%" valign="top"><p>The management agent on the attached router/container.
This address would be used by an endpoint that is a management
client/console/tool wishing to access management data from the attached
container.</p></td>
</tr>
<tr>
<td align="left" width="36%" valign="top"><p><code>_topo/0/Router.E/$management</code></p></td>
<td align="left" width="64%" valign="top"><p>The management agent at Router.E in area
0. This address would be used by a management client wishing to access
management data from a specific container that is reachable within the
network.</p></td>
</tr>
<tr>
<td align="left" width="36%" valign="top"><p><code>_local/qdhello</code></p></td>
<td align="left" width="64%" valign="top"><p>The router entity in each of the connected routers.
This address is used to communicate with neighbor routers and is
exclusively for the HELLO discovery protocol.</p></td>
</tr>
<tr>
<td align="left" width="36%" valign="top"><p><code>_local/qdrouter</code></p></td>
<td align="left" width="64%" valign="top"><p>The router entity in each of the connected routers.
This address is used by a router to communicate with other routers in
the network.</p></td>
</tr>
<tr>
<td align="left" width="36%" valign="top"><p><code>_topo/0/Router.E/qdrouter</code></p></td>
<td align="left" width="64%" valign="top"><p>The router entity at the specifically
indicated router. This address form is used by a router to communicate
with a specific router that may or may not be a neighbor.</p></td>
</tr>
</tbody>
</table>
</div>
<h4><a name="implementation-of-the-amqp-management-specification"></a>3.3.5. Implementation of the AMQP Management Specification</h4>
<p>Qpid Dispatch is manageable remotely via AMQP. It is compliant with the
emerging AMQP Management specification (draft 9).</p>
<p>Differences from the specification:</p>
<ul>
<li>
<p>
The <code>name</code> attribute is not required when an entity is created. If
   not supplied it will be set to the same value as the system-generated
   "identity" attribute. Otherwise it is treated as per the standard.
</p>
</li>
<li>
<p>
The <code>REGISTER</code> and <code>DEREGISTER</code> operations are not implemented. The router
   automatically discovers peer routers via the router network and makes
   their management addresses available via the standard <code>GET-MGMT-NODES</code>
   operation.
= Management Schema
</p>
</li>
</ul>
<p>This chapter documents the set of <strong>management entity types</strong> that define
configuration and management of a Dispatch Router. A management entity type has
a set of <strong>attributes</strong> that can be read, some attributes can also be
updated. Some entity types also support <strong>operations</strong> that can be called.</p>
<p>All management entity types have the following standard attributes:</p>
<dl>
<dt>
type
</dt>
<dd>
<p>
  The fully qualified type of the entity,
  e.g. <code>org.apache.qpid.dispatch.router</code>. This document uses the short name
  without the <code>org.apache.qpid.dispatch</code> prefix e.g. <code>router</code>. The dispatch
  tools will accept the short or long name.
</p>
</dd>
<dt>
name
</dt>
<dd>
<p>
  A user-generated identity for the entity.  This can be used in other entities
  that need to refer to the named entity.
</p>
</dd>
<dt>
identity
</dt>
<dd>
<p>
  A system-generated identity of the entity. It includes
  the short type name and some identifying information. E.g. <code>log/AGENT</code> or
  <code>listener/localhost:amqp</code>
</p>
</dd>
</dl>
<p>There are two main categories of management entity type.</p>
<dl>
<dt>
Configuration Entities
</dt>
<dd>
<p>
  Parameters that can be set in the configuration file
  (see <code>qdrouterd.conf(5)</code> man page) or set at run-time with the <code>qdmanage(8)</code>
  tool.
</p>
</dd>
<dt>
Operational Entities
</dt>
<dd>
<p>
   Run-time status values that can be queried using <code>qdstat(8)</code> or <code>qdmanage(8)</code> tools.
</p>
</dd>
</dl>
<h3><a name="_configuration_entities"></a>3.4. Configuration Entities</h3>
<p>Configuration entities define the attributes allowed in the configuration file
(see <code>qdrouterd.conf(5)</code>) but you can also create entities once the router is
running using the <code>qdrouterd(8)</code> tool&#8217;s <code>create</code> operation. Some entities can also
be modified using the <code>update</code> operation, see the entity descriptions below.</p>
<h4><a name="_container"></a>3.4.1. container</h4>
<p>(DEPRECATED)Attributes related to the AMQP container. This entity has been deprecated. Use the router entity instead.</p>
<p>Operations allowed: <code>READ</code></p>
<dl>
<dt>
<em>containerName</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  The  name of the AMQP container.  If not specified, the container name will be set to a value of the container&#8217;s choosing.  The automatically assigned container name is not guaranteed to be persistent across restarts of the container.
</p>
</dd>
<dt>
<em>workerThreads</em> (integer, default=4, <code>CREATE</code>)
</dt>
<dd>
<p>
  The number of threads that will be created to process message traffic and other application work (timers, non-amqp file descriptors, etc.) .
</p>
</dd>
<dt>
<em>debugDump</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  A file to dump debugging information that can&#8217;t be logged normally.
</p>
</dd>
<dt>
<em>saslConfigPath</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  Absolute path to the SASL configuration file.
</p>
</dd>
<dt>
<em>saslConfigName</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  Name of the SASL configuration.  This string + <em>.conf</em> is the name of the configuration file.
</p>
</dd>
</dl>
<h4><a name="_router"></a>3.4.2. router</h4>
<p>Tracks peer routers and computes routes to destinations.</p>
<p>Operations allowed: <code>READ</code></p>
<dl>
<dt>
<em>routerId</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  (DEPRECATED) Router&#8217;s unique identity. This attribute has been deprecated. Use id instead
</p>
</dd>
<dt>
<em>id</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  Router&#8217;s unique identity. One of id or routerId is required. The router will fail to start without id or routerId
</p>
</dd>
<dt>
<em>mode</em> (One of [<em>standalone</em>, <em>interior</em>], default=<em>standalone</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  In standalone mode, the router operates as a single component.  It does not participate in the routing protocol and therefore will not cooperate with other routers. In interior mode, the router operates in cooperation with other interior routers in an interconnected network.
</p>
</dd>
<dt>
<em>area</em> (string)
</dt>
<dd>
<p>
  Unused placeholder.
</p>
</dd>
<dt>
<em>helloInterval</em> (integer, default=1, <code>CREATE</code>)
</dt>
<dd>
<p>
  Interval in seconds between HELLO messages sent to neighbor routers.
</p>
</dd>
<dt>
<em>helloMaxAge</em> (integer, default=3, <code>CREATE</code>)
</dt>
<dd>
<p>
  Time in seconds after which a neighbor is declared lost if no HELLO is received.
</p>
</dd>
<dt>
<em>raInterval</em> (integer, default=30, <code>CREATE</code>)
</dt>
<dd>
<p>
  Interval in seconds between Router-Advertisements sent to all routers in a stable network.
</p>
</dd>
<dt>
<em>raIntervalFlux</em> (integer, default=4, <code>CREATE</code>)
</dt>
<dd>
<p>
  Interval in seconds between Router-Advertisements sent to all routers during topology fluctuations.
</p>
</dd>
<dt>
<em>remoteLsMaxAge</em> (integer, default=60, <code>CREATE</code>)
</dt>
<dd>
<p>
  Time in seconds after which link state is declared stale if no RA is received.
</p>
</dd>
<dt>
<em>mobileAddrMaxAge</em> (integer, default=60, <code>CREATE</code>)
</dt>
<dd>
<p>
  (DEPRECATED) This value is no longer used in the router.
</p>
</dd>
<dt>
<em>addrCount</em> (integer)
</dt>
<dd>
<p>
  Number of addresses known to the router.
</p>
</dd>
<dt>
<em>linkCount</em> (integer)
</dt>
<dd>
<p>
  Number of links attached to the router node.
</p>
</dd>
<dt>
<em>nodeCount</em> (integer)
</dt>
<dd>
<p>
  Number of known peer router nodes.
</p>
</dd>
<dt>
<em>workerThreads</em> (integer, default=4, <code>CREATE</code>)
</dt>
<dd>
<p>
  The number of threads that will be created to process message traffic and other application work (timers, non-amqp file descriptors, etc.) .
</p>
</dd>
<dt>
<em>debugDump</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  A file to dump debugging information that can&#8217;t be logged normally.
</p>
</dd>
<dt>
<em>saslConfigPath</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  Absolute path to the SASL configuration file.
</p>
</dd>
<dt>
<em>saslConfigName</em> (string, default=<em>qdrouterd</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  Name of the SASL configuration.  This string + <em>.conf</em> is the name of the configuration file.
</p>
</dd>
</dl>
<h4><a name="_listener"></a>3.4.3. listener</h4>
<p>Listens for incoming connections to the router.</p>
<p>Operations allowed: <code>CREATE</code>, <code>DELETE</code>, <code>READ</code></p>
<dl>
<dt>
<em>addr</em> (string, default=<em>127.0.0.1</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  (DEPRECATED)IP address: ipv4 or ipv6 literal or a host name. This attribute has been deprecated. Use host instead
</p>
</dd>
<dt>
<em>host</em> (string, default=<em>127.0.0.1</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  IP address: ipv4 or ipv6 literal or a host name
</p>
</dd>
<dt>
<em>port</em> (string, default=<em>amqp</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  Port number or symbolic service name.
</p>
</dd>
<dt>
<em>protocolFamily</em> (One of [<em>IPv4</em>, <em>IPv6</em>], <code>CREATE</code>)
</dt>
<dd>
<p>
  [<em>IPv4</em>, <em>IPv6</em>] IPv4: Internet Protocol version 4; IPv6: Internet Protocol version 6.  If not specified, the protocol family will be automatically determined from the address.
</p>
</dd>
<dt>
<em>role</em> (One of [<em>normal</em>, <em>inter-router</em>, <em>route-container</em>, <em>on-demand</em>], default=<em>normal</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  The role of an established connection. In the normal role, the connection is assumed to be used for AMQP clients that are doing normal message delivery over the connection.  In the inter-router role, the connection is assumed to be to another router in the network.  Inter-router discovery and routing protocols can only be used over inter-router connections. route-container role can be used for router-container connections, for example, a router-broker connection. on-demand role has been deprecated.
</p>
</dd>
<dt>
<em>cost</em> (integer, default=<em>1</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  For the <em>inter-router</em> role only.  This value assigns a cost metric to the inter-router connection.  The default (and minimum) value is one.  Higher values represent higher costs.  The cost is used to influence the routing algorithm as it attempts to use the path with the lowest total cost from ingress to egress.
</p>
</dd>
<dt>
<em>certDb</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  The absolute path to the database that contains the public certificates of trusted certificate authorities (CA).
</p>
</dd>
<dt>
<em>certFile</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  The absolute path to the file containing the PEM-formatted public certificate to be used on the local end of any connections using this profile.
</p>
</dd>
<dt>
<em>keyFile</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  The absolute path to the file containing the PEM-formatted private key for the above certificate.
</p>
</dd>
<dt>
<em>passwordFile</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  If the above private key is password protected, this is the absolute path to a file containing the password that unlocks the certificate key.
</p>
</dd>
<dt>
<em>password</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  An alternative to storing the password in a file referenced by passwordFile is to supply the password right here in the configuration file.  This option can be used by supplying the password in the <em>password</em> option.  Don&#8217;t use both password and passwordFile in the same profile.
</p>
</dd>
<dt>
<em>uidFormat</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  A list of x509 client certificate fields that will be used to build a string that will uniquely identify the client certificate owner. For e.g. a value of <em>cou</em> indicates that the uid will consist of c - common name concatenated with o - organization-company name concatenated with u - organization unit; or a value of <em>o2</em> indicates that the uid will consist of o (organization name) concatenated with 2 (the sha256 fingerprint of the entire certificate) . Allowed values can be any combination of <em>c</em>( ISO3166 two character country code), <em>s</em>(state or province), <em>l</em>(Locality; generally - city), <em>o</em>(Organization - Company Name), <em>u</em>(Organization Unit - typically certificate type or brand), <em>n</em>(CommonName - typically a user name for client certificates) and <em>1</em>(sha1 certificate fingerprint, as displayed in the fingerprints section when looking at a certificate with say a web browser is the hash of the entire certificate) and 2 (sha256 certificate fingerprint) and 5 (sha512 certificate fingerprint).
</p>
</dd>
<dt>
<em>displayNameFile</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  The absolute path to the file containing the unique id to dispay name mapping
</p>
</dd>
<dt>
<em>sslProfileName</em> (string)
</dt>
<dd>
<p>
  The name of the ssl profile. This is for internal use only. Use the <em>name</em> attribute to assign a name to an sslProfile section
</p>
</dd>
<dt>
<em>saslMechanisms</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  Space separated list of accepted SASL authentication mechanisms.
</p>
</dd>
<dt>
<em>authenticatePeer</em> (boolean, <code>CREATE</code>)
</dt>
<dd>
<p>
  yes: Require the peer&#8217;s identity to be authenticated; no: Do not require any authentication.
</p>
</dd>
<dt>
<em>requireEncryption</em> (boolean, <code>CREATE</code>)
</dt>
<dd>
<p>
  yes: Require the connection to the peer to be encrypted; no: Permit non-encrypted communication with the peer
</p>
</dd>
<dt>
<em>requireSsl</em> (boolean, <code>CREATE</code>)
</dt>
<dd>
<p>
  yes: Require the use of SSL or TLS on the connection; no: Allow clients to connect without SSL or TLS.
</p>
</dd>
<dt>
<em>trustedCerts</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  This optional setting can be used to reduce the set of available CAs for client authentication.  If used, this setting must provide the absolute path to a PEM file that contains the trusted certificates.
</p>
</dd>
<dt>
<em>maxFrameSize</em> (integer, default=16384, <code>CREATE</code>)
</dt>
<dd>
<p>
  Defaults to 16384.  If specified, it is the maximum frame size in octets that will be used in the connection-open negotiation with a connected peer.  The frame size is the largest contiguous set of uninterrupted data that can be sent for a message delivery over the connection. Interleaving of messages on different links is done at frame granularity.
</p>
</dd>
<dt>
<em>idleTimeoutSeconds</em> (integer, default=16, <code>CREATE</code>)
</dt>
<dd>
<p>
  The idle timeout, in seconds, for connections through this listener.  If no frames are received on the connection for this time interval, the connection shall be closed.
</p>
</dd>
<dt>
<em>requirePeerAuth</em> (boolean, <code>CREATE</code>)
</dt>
<dd>
<p>
  (DEPRECATED) This attribute is now controlled by the authenticatePeer attribute.
</p>
</dd>
<dt>
<em>allowUnsecured</em> (boolean, <code>CREATE</code>)
</dt>
<dd>
<p>
  (DEPRECATED) This attribute is now controlled by the requireEncryption attribute.
</p>
</dd>
<dt>
<em>allowNoSasl</em> (boolean, <code>CREATE</code>)
</dt>
<dd>
<p>
  (DEPRECATED) This attribute is now controlled by the authenticatePeer attribute.
</p>
</dd>
<dt>
<em>stripAnnotations</em> (One of [<em>in</em>, <em>out</em>, <em>both</em>, <em>no</em>], default=<em>both</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  [<em>in</em>, <em>out</em>, <em>both</em>, <em>no</em>] in: Strip the dispatch router specific annotations only on ingress; out: Strip the dispatch router specific annotations only on egress; both: Strip the dispatch router specific annotations on both ingress and egress; no - do not strip dispatch router specific annotations
</p>
</dd>
<dt>
<em>linkCapacity</em> (integer, <code>CREATE</code>)
</dt>
<dd>
<p>
  The capacity of links within this connection, in terms of message deliveries.  The capacity is the number of messages that can be in-flight concurrently for each link.
</p>
</dd>
</dl>
<h4><a name="_connector"></a>3.4.4. connector</h4>
<p>Establishes an outgoing connection from the router.</p>
<p>Operations allowed: <code>CREATE</code>, <code>DELETE</code>, <code>READ</code></p>
<dl>
<dt>
<em>addr</em> (string, default=<em>127.0.0.1</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  (DEPRECATED)IP address: ipv4 or ipv6 literal or a host name. This attribute has been deprecated. Use host instead
</p>
</dd>
<dt>
<em>host</em> (string, default=<em>127.0.0.1</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  IP address: ipv4 or ipv6 literal or a host name
</p>
</dd>
<dt>
<em>port</em> (string, default=<em>amqp</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  Port number or symbolic service name.
</p>
</dd>
<dt>
<em>protocolFamily</em> (One of [<em>IPv4</em>, <em>IPv6</em>], <code>CREATE</code>)
</dt>
<dd>
<p>
  [<em>IPv4</em>, <em>IPv6</em>] IPv4: Internet Protocol version 4; IPv6: Internet Protocol version 6.  If not specified, the protocol family will be automatically determined from the address.
</p>
</dd>
<dt>
<em>role</em> (One of [<em>normal</em>, <em>inter-router</em>, <em>route-container</em>, <em>on-demand</em>], default=<em>normal</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  The role of an established connection. In the normal role, the connection is assumed to be used for AMQP clients that are doing normal message delivery over the connection.  In the inter-router role, the connection is assumed to be to another router in the network.  Inter-router discovery and routing protocols can only be used over inter-router connections. route-container role can be used for router-container connections, for example, a router-broker connection. on-demand role has been deprecated.
</p>
</dd>
<dt>
<em>cost</em> (integer, default=<em>1</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  For the <em>inter-router</em> role only.  This value assigns a cost metric to the inter-router connection.  The default (and minimum) value is one.  Higher values represent higher costs.  The cost is used to influence the routing algorithm as it attempts to use the path with the lowest total cost from ingress to egress.
</p>
</dd>
<dt>
<em>certDb</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  The absolute path to the database that contains the public certificates of trusted certificate authorities (CA).
</p>
</dd>
<dt>
<em>certFile</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  The absolute path to the file containing the PEM-formatted public certificate to be used on the local end of any connections using this profile.
</p>
</dd>
<dt>
<em>keyFile</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  The absolute path to the file containing the PEM-formatted private key for the above certificate.
</p>
</dd>
<dt>
<em>passwordFile</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  If the above private key is password protected, this is the absolute path to a file containing the password that unlocks the certificate key.
</p>
</dd>
<dt>
<em>password</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  An alternative to storing the password in a file referenced by passwordFile is to supply the password right here in the configuration file.  This option can be used by supplying the password in the <em>password</em> option.  Don&#8217;t use both password and passwordFile in the same profile.
</p>
</dd>
<dt>
<em>uidFormat</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  A list of x509 client certificate fields that will be used to build a string that will uniquely identify the client certificate owner. For e.g. a value of <em>cou</em> indicates that the uid will consist of c - common name concatenated with o - organization-company name concatenated with u - organization unit; or a value of <em>o2</em> indicates that the uid will consist of o (organization name) concatenated with 2 (the sha256 fingerprint of the entire certificate) . Allowed values can be any combination of <em>c</em>( ISO3166 two character country code), <em>s</em>(state or province), <em>l</em>(Locality; generally - city), <em>o</em>(Organization - Company Name), <em>u</em>(Organization Unit - typically certificate type or brand), <em>n</em>(CommonName - typically a user name for client certificates) and <em>1</em>(sha1 certificate fingerprint, as displayed in the fingerprints section when looking at a certificate with say a web browser is the hash of the entire certificate) and 2 (sha256 certificate fingerprint) and 5 (sha512 certificate fingerprint).
</p>
</dd>
<dt>
<em>displayNameFile</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  The absolute path to the file containing the unique id to dispay name mapping
</p>
</dd>
<dt>
<em>sslProfileName</em> (string)
</dt>
<dd>
<p>
  The name of the ssl profile. This is for internal use only. Use the <em>name</em> attribute to assign a name to an sslProfile section
</p>
</dd>
<dt>
<em>saslMechanisms</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  Space separated list of accepted SASL authentication mechanisms.
</p>
</dd>
<dt>
<em>allowRedirect</em> (boolean, default=True, <code>CREATE</code>)
</dt>
<dd>
<p>
  Allow the peer to redirect this connection to another address.
</p>
</dd>
<dt>
<em>maxFrameSize</em> (integer, default=65536, <code>CREATE</code>)
</dt>
<dd>
<p>
  Maximum frame size in octets that will be used in the connection-open negotiation with a connected peer.  The frame size is the largest contiguous set of uninterrupted data that can be sent for a message delivery over the connection. Interleaving of messages on different links is done at frame granularity.
</p>
</dd>
<dt>
<em>idleTimeoutSeconds</em> (integer, default=16, <code>CREATE</code>)
</dt>
<dd>
<p>
  The idle timeout, in seconds, for connections through this connector.  If no frames are received on the connection for this time interval, the connection shall be closed.
</p>
</dd>
<dt>
<em>stripAnnotations</em> (One of [<em>in</em>, <em>out</em>, <em>both</em>, <em>no</em>], default=<em>both</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  [<em>in</em>, <em>out</em>, <em>both</em>, <em>no</em>] in: Strip the dispatch router specific annotations only on ingress; out: Strip the dispatch router specific annotations only on egress; both: Strip the dispatch router specific annotations on both ingress and egress; no - do not strip dispatch router specific annotations
</p>
</dd>
<dt>
<em>linkCapacity</em> (integer, <code>CREATE</code>)
</dt>
<dd>
<p>
  The capacity of links within this connection, in terms of message deliveries.  The capacity is the number of messages that can be in-flight concurrently for each link.
</p>
</dd>
<dt>
<em>verifyHostName</em> (boolean, default=True, <code>CREATE</code>)
</dt>
<dd>
<p>
  yes: Ensures that when initiating a connection (as a client) the host name in the URL to which this connector connects to matches the host name in the digital certificate that the peer sends back as part of the SSL connection; no: Does not perform host name verification
</p>
</dd>
<dt>
<em>saslUsername</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  The user name that the connector is using to connect to a peer.
</p>
</dd>
<dt>
<em>saslPassword</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  The password that the connector is using to connect to a peer.
</p>
</dd>
</dl>
<h4><a name="_log"></a>3.4.5. log</h4>
<p>Configure logging for a particular module. You can use the <code>UPDATE</code> operation to change log settings while the router is running.</p>
<p>Operations allowed: <code>UPDATE</code>, <code>READ</code></p>
<dl>
<dt>
<em>module</em> (One of [<em>ROUTER</em>, <em>ROUTER_CORE</em>, <em>ROUTER_HELLO</em>, <em>ROUTER_LS</em>, <em>ROUTER_MA</em>, <em>MESSAGE</em>, <em>SERVER</em>, <em>AGENT</em>, <em>CONTAINER</em>, <em>ERROR</em>, <em>POLICY</em>, <em>DEFAULT</em>], required, <code>UPDATE</code>)
</dt>
<dd>
<p>
  Module to configure. The special module <em>DEFAULT</em> specifies defaults for all modules.
</p>
</dd>
<dt>
<em>enable</em> (string, <code>UPDATE</code>)
</dt>
<dd>
<p>
  Levels are: trace, debug, info, notice, warning, error, critical. The enable string is a comma-separated list of levels. A level may have a trailing <em>+</em> to enable that level and above. For example <em>trace,debug,warning+</em> means enable trace, debug, warning, error and critical. The value <em>none</em> means disable logging for the module.
</p>
</dd>
<dt>
<em>timestamp</em> (boolean, <code>UPDATE</code>)
</dt>
<dd>
<p>
  Include timestamp in log messages.
</p>
</dd>
<dt>
<em>source</em> (boolean, <code>UPDATE</code>)
</dt>
<dd>
<p>
  Include source file and line number in log messages.
</p>
</dd>
<dt>
<em>output</em> (string, <code>UPDATE</code>)
</dt>
<dd>
<p>
  Where to send log messages. Can be <em>stderr</em>, <em>stdout</em>, <em>syslog</em> or a file name.
</p>
</dd>
</dl>
<h4><a name="_fixedaddress"></a>3.4.6. fixedAddress</h4>
<p>(DEPRECATED) Establishes treatment for addresses starting with a prefix. This entity has been deprecated. Use address instead</p>
<p>Operations allowed: <code>CREATE</code>, <code>READ</code></p>
<dl>
<dt>
<em>prefix</em> (string, required, <code>CREATE</code>)
</dt>
<dd>
<p>
  The address prefix (always starting with <em>/</em>).
</p>
</dd>
<dt>
<em>phase</em> (integer, <code>CREATE</code>)
</dt>
<dd>
<p>
  The phase of a multi-hop address passing through one or more waypoints.
</p>
</dd>
<dt>
<em>fanout</em> (One of [<em>multiple</em>, <em>single</em>], default=<em>multiple</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  One of <em>multiple</em> or <em>single</em>.  Multiple fanout is a non-competing pattern.  If there are multiple consumers using the same address, each consumer will receive its own copy of every message sent to the address.  Single fanout is a competing pattern where each message is sent to only one consumer.
</p>
</dd>
<dt>
<em>bias</em> (One of [<em>closest</em>, <em>spread</em>], default=<em>closest</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  Only if fanout is single.  One of <em>closest</em> or <em>spread</em>.  Closest bias means that messages to an address will always be delivered to the closest (lowest cost) subscribed consumer. Spread bias will distribute the messages across subscribers in an approximately even manner.
</p>
</dd>
</dl>
<h4><a name="_waypoint"></a>3.4.7. waypoint</h4>
<p>(DEPRECATED) A remote node that messages for an address pass through. This entity has been deprecated. Use autoLink instead</p>
<p>Operations allowed: <code>CREATE</code>, <code>DELETE</code>, <code>READ</code></p>
<dl>
<dt>
<em>address</em> (string, required, <code>CREATE</code>)
</dt>
<dd>
<p>
  The AMQP address of the waypoint.
</p>
</dd>
<dt>
<em>connector</em> (string, required, <code>CREATE</code>)
</dt>
<dd>
<p>
  The name of the on-demand connector used to reach the waypoint&#8217;s container.
</p>
</dd>
<dt>
<em>inPhase</em> (integer, default=-1, <code>CREATE</code>)
</dt>
<dd>
<p>
  The phase of the address as it is routed <em>to</em> the waypoint.
</p>
</dd>
<dt>
<em>outPhase</em> (integer, default=-1, <code>CREATE</code>)
</dt>
<dd>
<p>
  The phase of the address as it is routed <em>from</em> the waypoint.
</p>
</dd>
</dl>
<h4><a name="_linkroutepattern"></a>3.4.8. linkRoutePattern</h4>
<p>(DEPRECATED) An address pattern to match against link sources and targets to cause the router to link-route the attach across the network to a remote node. This entity has been deprecated. Use linkRoute instead</p>
<p>Operations allowed: <code>CREATE</code>, <code>READ</code></p>
<dl>
<dt>
<em>prefix</em> (string, required, <code>CREATE</code>)
</dt>
<dd>
<p>
  An address prefix to match against target and source addresses.  This pattern must be of the form <em>&lt;text&gt;.&lt;text1&gt;.&lt;textN&gt;</em> or <em>&lt;text&gt;</em> or <em>&lt;text&gt;.</em> and matches any address that contains that prefix.  For example, if the prefix is set to org.apache (or org.apache.), any address that has the prefix <em>org.apache</em>  (like org.apache.dev) will match. Note that a prefix must not start with a (.), can end in a (.) and can contain zero or more dots (.).  Any characters between the dots are simply treated as part of the address
</p>
</dd>
<dt>
<em>dir</em> (One of [<em>in</em>, <em>out</em>, <em>both</em>], default=<em>both</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  Link direction for match: <em>in</em> matches only links inbound to the client; <em>out</em> matches only links outbound from the client; <em>both</em> matches any link.
</p>
</dd>
<dt>
<em>connector</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  The name of the on-demand connector used to reach the target node&#8217;s container.  If this value is not provided, it means that the target container is expected to be connected to a different router in the network.  This prevents links to a link-routable address from being misinterpreted as message-routing links when there is no route to a valid destination available.
</p>
</dd>
</dl>
<h4><a name="_address"></a>3.4.9. address</h4>
<p>Entity type for address configuration.  This is used to configure the treatment of message-routed deliveries within a particular address-space.  The configuration controls distribution and address phasing.</p>
<p>Operations allowed: <code>CREATE</code>, <code>DELETE</code>, <code>READ</code></p>
<dl>
<dt>
<em>prefix</em> (string, required, <code>CREATE</code>)
</dt>
<dd>
<p>
  The address prefix for the configured settings
</p>
</dd>
<dt>
<em>distribution</em> (One of [<em>multicast</em>, <em>closest</em>, <em>balanced</em>], default=<em>balanced</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  Treatment of traffic associated with the address
</p>
</dd>
<dt>
<em>waypoint</em> (boolean, <code>CREATE</code>)
</dt>
<dd>
<p>
  Designates this address space as being used for waypoints.  This will cause the proper address-phasing to be used.
</p>
</dd>
<dt>
<em>ingressPhase</em> (integer, <code>CREATE</code>)
</dt>
<dd>
<p>
  Advanced - Override the ingress phase for this address
</p>
</dd>
<dt>
<em>egressPhase</em> (integer, <code>CREATE</code>)
</dt>
<dd>
<p>
  Advanced - Override the egress phase for this address
</p>
</dd>
</dl>
<h4><a name="_linkroute"></a>3.4.10. linkRoute</h4>
<p>Entity type for link-route configuration.  This is used to identify remote containers that shall be destinations for routed link-attaches.  The link-routing configuration applies to an addressing space defined by a prefix.</p>
<p>Operations allowed: <code>CREATE</code>, <code>DELETE</code>, <code>READ</code></p>
<dl>
<dt>
<em>prefix</em> (string, required, <code>CREATE</code>)
</dt>
<dd>
<p>
  The address prefix for the configured settings
</p>
</dd>
<dt>
<em>containerId</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  ContainerID for the target container
</p>
</dd>
<dt>
<em>connection</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  The name from a connector or listener
</p>
</dd>
<dt>
<em>distribution</em> (One of [<em>linkBalanced</em>], default=<em>linkBalanced</em>, <code>CREATE</code>)
</dt>
<dd>
<p>
  Treatment of traffic associated with the address
</p>
</dd>
<dt>
<em>dir</em> (One of [<em>in</em>, <em>out</em>], required, <code>CREATE</code>)
</dt>
<dd>
<p>
  The permitted direction of links: <em>in</em> means client senders; <em>out</em> means client receivers
</p>
</dd>
<dt>
<em>operStatus</em> (One of [<em>inactive</em>, <em>active</em>])
</dt>
<dd>
<p>
  The operational status of this linkRoute: inactive - The remote container is not connected; active - the remote container is connected and ready to accept link routed attachments.
</p>
</dd>
</dl>
<h4><a name="_autolink"></a>3.4.11. autoLink</h4>
<p>Entity type for configuring auto-links.  Auto-links are links whose lifecycle is managed by the router.  These are typically used to attach to waypoints on remote containers (brokers, etc.).</p>
<p>Operations allowed: <code>CREATE</code>, <code>DELETE</code>, <code>READ</code></p>
<dl>
<dt>
<em>addr</em> (string, required, <code>CREATE</code>)
</dt>
<dd>
<p>
  The address of the provisioned object
</p>
</dd>
<dt>
<em>dir</em> (One of [<em>in</em>, <em>out</em>], required, <code>CREATE</code>)
</dt>
<dd>
<p>
  The direction of the link to be created.  In means into the router, out means out of the router.
</p>
</dd>
<dt>
<em>phase</em> (integer, <code>CREATE</code>)
</dt>
<dd>
<p>
  The address phase for this link.  Defaults to <em>0</em> for <em>out</em> links and <em>1</em> for <em>in</em> links.
</p>
</dd>
<dt>
<em>containerId</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  ContainerID for the target container
</p>
</dd>
<dt>
<em>connection</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  The name from a connector or listener
</p>
</dd>
<dt>
<em>linkRef</em> (string)
</dt>
<dd>
<p>
  Reference to the org.apache.qpid.dispatch.router.link if the link exists
</p>
</dd>
<dt>
<em>operStatus</em> (One of [<em>inactive</em>, <em>attaching</em>, <em>failed</em>, <em>active</em>, <em>quiescing</em>, <em>idle</em>])
</dt>
<dd>
<p>
  The operational status of this autoLink: inactive - The remote container is not connected; attaching - the link is attaching to the remote node; failed - the link attach failed; active - the link is attached and operational; quiescing - the link is transitioning to idle state; idle - the link is attached but there are no deliveries flowing and no unsettled deliveries.
</p>
</dd>
<dt>
<em>lastError</em> (string)
</dt>
<dd>
<p>
  The error description from the last attach failure
</p>
</dd>
</dl>
<h4><a name="_console"></a>3.4.12. console</h4>
<p>Start a websocket/tcp proxy and http file server to serve the web console</p>
<p>Operations allowed: <code>READ</code></p>
<dl>
<dt>
<em>listener</em> (string)
</dt>
<dd>
<p>
  The name of the listener to send the proxied tcp traffic to.
</p>
</dd>
<dt>
<em>wsport</em> (integer, default=5673)
</dt>
<dd>
<p>
  port on which to listen for websocket traffic
</p>
</dd>
<dt>
<em>proxy</em> (string)
</dt>
<dd>
<p>
  The full path to the proxy program to run.
</p>
</dd>
<dt>
<em>home</em> (string)
</dt>
<dd>
<p>
  The full path to the html/css/js files for the console.
</p>
</dd>
<dt>
<em>args</em> (string)
</dt>
<dd>
<p>
  Optional args to pass the proxy program for logging, authentication, etc.
</p>
</dd>
</dl>
<h4><a name="_policy"></a>3.4.13. policy</h4>
<p>Defines global connection limit</p>
<p>Operations allowed: <code>READ</code></p>
<dl>
<dt>
<em>maximumConnections</em> (integer, <code>CREATE</code>)
</dt>
<dd>
<p>
  Global maximum number of concurrent client connections allowed. Zero implies no limit. This limit is always enforced even if no other policy settings have been defined.
</p>
</dd>
<dt>
<em>enableAccessRules</em> (boolean, <code>CREATE</code>)
</dt>
<dd>
<p>
  Enable user rule set processing and connection denial.
</p>
</dd>
<dt>
<em>policyFolder</em> (path, <code>CREATE</code>)
</dt>
<dd>
<p>
  The absolute path to a folder that holds policyRuleset definition .json files. For a small system the rulesets may all be defined in this file. At a larger scale it is better to have the policy files in their own folder and to have none of the rulesets defined here. All rulesets in all .json files in this folder are processed.
</p>
</dd>
<dt>
<em>defaultApplication</em> (string, <code>CREATE</code>)
</dt>
<dd>
<p>
  Application policyRuleset to use for connections with no open.hostname or a hostname that does not match any existing policy. For users that don&#8217;t wish to use open.hostname or any multi-tennancy feature, this default policy can be the only policy in effect for the network.
</p>
</dd>
<dt>
<em>defaultApplicationEnabled</em> (boolean, <code>CREATE</code>)
</dt>
<dd>
<p>
  Enable defaultApplication policy fallback logic.
</p>
</dd>
<dt>
<em>connectionsProcessed</em> (integer)
</dt>
<dt>
<em>connectionsDenied</em> (integer)
</dt>
<dt>
<em>connectionsCurrent</em> (integer)
</dt>
<dd>
<p>
=== policyRuleset
</p>
</dd>
</dl>
<p>Per application definition of the locations from which users may connect and the groups to which users belong.</p>
<p>Operations allowed: <code>CREATE</code>, <code>READ</code></p>
<dl>
<dt>
<em>applicationName</em> (string, required)
</dt>
<dd>
<p>
  The application name.
</p>
</dd>
<dt>
<em>maxConnections</em> (integer, <code>CREATE</code>)
</dt>
<dd>
<p>
  Maximum number of concurrent client connections allowed. Zero implies no limit.
</p>
</dd>
<dt>
<em>maxConnPerUser</em> (integer, <code>CREATE</code>)
</dt>
<dd>
<p>
  Maximum number of concurrent client connections allowed for any single user. Zero implies no limit.
</p>
</dd>
<dt>
<em>maxConnPerHost</em> (integer, <code>CREATE</code>)
</dt>
<dd>
<p>
  Maximum number of concurrent client connections allowed for any remote host. Zero implies no limit.
</p>
</dd>
<dt>
<em>userGroups</em> (map, <code>CREATE</code>)
</dt>
<dd>
<p>
  A map where each key is a user group name and the corresponding value is a CSV string naming the users in that group. Users who are assigned to one or more groups are deemed <em>restricted</em>. Restricted users are subject to connection ingress policy and are assigned policy settings based on the assigned user groups. Unrestricted users may be allowed or denied. If unrestricted users are allowed to connect then they are assigned to user group default.
</p>
</dd>
<dt>
<em>ingressHostGroups</em> (map, <code>CREATE</code>)
</dt>
<dd>
<p>
  A map where each key is an ingress host group name and the corresponding value is a CSV string naming the IP addresses or address ranges in that group. IP addresses may be FQDN strings or numeric IPv4 or IPv6 host addresses. A host range is two host addresses of the same address family separated with a hyphen.  The wildcard host address <em>*</em> represents any host address.
</p>
</dd>
<dt>
<em>ingressPolicies</em> (map, <code>CREATE</code>)
</dt>
<dd>
<p>
  A map where each key is a user group name and the corresponding value is a CSV string naming the ingress host group names that restrict the ingress host for the user group. Users who are members of the user group are allowed to connect only from a host in one of the named ingress host groups.
</p>
</dd>
<dt>
<em>connectionAllowDefault</em> (boolean, <code>CREATE</code>)
</dt>
<dd>
<p>
  Unrestricted users, those who are not members of a defined user group, are allowed to connect to this application. Unrestricted users are assigned to the <em>default</em> user group and receive <em>default</em> settings.
</p>
</dd>
<dt>
<em>settings</em> (map, <code>CREATE</code>)
</dt>
<dd>
<p>
  A map where each key is a user group name and the value is a map of the corresponding settings for that group.
</p>
</dd>
</dl>
<h3><a name="_operational_entities"></a>3.5. Operational Entities</h3>
<p>Operational entities provide statistics and other run-time attributes of the router.
The <code>qdstat(8)</code> tool provides a convenient way to query run-time statistics.
You can also use the general-purpose management tool <code>qdmanage(8)</code> to query
operational attributes.</p>
<h4><a name="_org_amqp_management"></a>3.5.1. org.amqp.management</h4>
<p>The standard AMQP management node interface.</p>
<p>Operations allowed: <code>QUERY</code>, <code>GET-TYPES</code>, <code>GET-ANNOTATIONS</code>, <code>GET-OPERATIONS</code>, <code>GET-ATTRIBUTES</code>, <code>GET-MGMT-NODES</code>, <code>READ</code></p>
<h5><a name="_operation_get_types"></a>Operation GET-TYPES</h5>
<p>Get the set of entity types and their inheritance relationships</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>entityType</em> (string)
</dt>
<dd>
<p>
  If set, restrict query results to entities that extend (directly or indirectly) this type
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>A map where each key is an entity type name (string) and the corresponding value is the list of the entity types (strings) that it extends.</p>
<h5><a name="_operation_get_attributes"></a>Operation GET-ATTRIBUTES</h5>
<p>Get the set of entity types and the annotations they implement</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>entityType</em> (string)
</dt>
<dd>
<p>
  If set, restrict query results to entities that extend (directly or indirectly) this type
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>A map where each key is an entity type name (string) and the corresponding value is a list (of strings) of attributes on that entity type.</p>
<h5><a name="_operation_get_operations"></a>Operation GET-OPERATIONS</h5>
<p>Get the set of entity types and the operations they support</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>entityType</em> (string)
</dt>
<dd>
<p>
  If set, restrict query results to entities that extend (directly or indirectly) this type
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>A map where each key is an entity type name (string) and the corresponding value is the list of operation names (strings) that it supports.</p>
<h5><a name="_operation_get_annotations"></a>Operation GET-ANNOTATIONS</h5>
<p><b>Request properties</b></p><dl>
<dt>
<em>entityType</em> (string)
</dt>
<dd>
<p>
  If set, restrict query results to entities that extend (directly or indirectly) this type
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>A map where each key is an entity type name (string) and the corresponding value is the list of annotations (strings) that it  implements.</p>
<h5><a name="_operation_query"></a>Operation QUERY</h5>
<p>Query for attribute values of multiple entities.</p>
<p><b>Request body (map)</b><br>A map containing the key <code>attributeNames</code> with value a list of (string) attribute names to return. If the list or the map is empty or the body is missing all attributes are returned.</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>count</em> (integer)
</dt>
<dd>
<p>
  If set, specifies the number of entries from the result set to return. If not set return all from <code>offset</code>
</p>
</dd>
<dt>
<em>entityType</em> (string)
</dt>
<dd>
<p>
  If set, restrict query results to entities that extend (directly or indirectly) this type
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
<dt>
<em>offset</em> (integer)
</dt>
<dd>
<p>
  If set, specifies the number of the first element of the result set to be returned.
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>A map with two entries. <code>attributeNames</code> is a list of the attribute names returned. <code>results</code> is a list of lists each containing the attribute values for a single entity in the same order as the names in the <code>attributeNames</code> entry. If an attribute name is not applicable for an entity then the corresponding value is <code>null</code></p>
<p><b>Response properties</b></p><dl>
<dt>
<em>count</em> (integer)
</dt>
<dd>
<p>
  Number of results returned
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<h5><a name="_operation_get_mgmt_nodes"></a>Operation GET-MGMT-NODES</h5>
<p>Get the addresses of all management nodes known to this router</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (list)</b><br>A list of addresses (strings) of management nodes known to this management node.</p>
<h4><a name="_management"></a>3.5.2. management</h4>
<p>Qpid dispatch router extensions to the standard org.amqp.management interface.</p>
<p>Operations allowed: <code>GET-SCHEMA</code>, <code>GET-JSON-SCHEMA</code>, <code>GET-LOG</code>, <code>PROFILE</code>, <code>QUERY</code>, <code>GET-TYPES</code>, <code>GET-ANNOTATIONS</code>, <code>GET-OPERATIONS</code>, <code>GET-ATTRIBUTES</code>, <code>GET-MGMT-NODES</code>, <code>READ</code></p>
<h5><a name="_operation_get_schema_json"></a>Operation GET-SCHEMA-JSON</h5>
<p>Get the qdrouterd schema for this router in JSON format</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>indent</em> (integer)
</dt>
<dd>
<p>
  Number of spaces to indent the formatted result. If not specified, the result is in minimal format, no unnecessary spaces or newlines.
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (string)</b><br>The qdrouter schema as a JSON string.</p>
<h5><a name="_operation_get_log"></a>Operation GET-LOG</h5>
<p>Get recent log entries from the router.</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>limit</em> (integer)
</dt>
<dd>
<p>
  Maximum number of log entries to get.
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (string)</b><br>A list of log entries where each entry is a list of: module name(string), level name(string), message text(string), file name(string or None), line number(integer or None) , timestamp(integer)</p>
<h5><a name="_operation_get_schema"></a>Operation GET-SCHEMA</h5>
<p>Get the qdrouterd schema for this router in AMQP map format</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>The qdrouter schema as a map.</p>
<h4><a name="_router_link"></a>3.5.3. router.link</h4>
<p>Link to another AMQP endpoint: router node, client or other AMQP process.</p>
<p>Operations allowed: <code>UPDATE</code>, <code>READ</code></p>
<dl>
<dt>
<em>adminStatus</em> (One of [<em>enabled</em>, <em>disabled</em>], default=<em>enabled</em>, <code>UPDATE</code>)
</dt>
<dt>
<em>operStatus</em> (One of [<em>up</em>, <em>down</em>, <em>quiescing</em>, <em>idle</em>])
</dt>
<dt>
<em>linkName</em> (string)
</dt>
<dd>
<p>
  Name assigned to the link in the Attach.
</p>
</dd>
<dt>
<em>linkType</em> (One of [<em>endpoint</em>, <em>router-control</em>, <em>inter-router</em>])
</dt>
<dd>
<p>
  Type of link: endpoint: a link to a normally connected endpoint; inter-router: a link to another router in the network.
</p>
</dd>
<dt>
<em>linkDir</em> (One of [<em>in</em>, <em>out</em>])
</dt>
<dd>
<p>
  Direction of delivery flow over the link, inbound or outbound to or from the router.
</p>
</dd>
<dt>
<em>owningAddr</em> (string)
</dt>
<dd>
<p>
  Address assigned to this link during attach: The target for inbound links or the source for outbound links.
</p>
</dd>
<dt>
<em>capacity</em> (integer)
</dt>
<dd>
<p>
  The capacity, in deliveries, for the link.  The number of undelivered plus unsettled deliveries shall not exceed the capacity.  This is enforced by link flow control.
</p>
</dd>
<dt>
<em>peer</em> (string)
</dt>
<dd>
<p>
  Identifier of the paired link if this is an attach-routed link.
</p>
</dd>
<dt>
<em>undeliveredCount</em> (integer)
</dt>
<dd>
<p>
  The number of undelivered messages pending for the link.
</p>
</dd>
<dt>
<em>unsettledCount</em> (integer)
</dt>
<dd>
<p>
  The number of unsettled deliveries awaiting settlement on the link
</p>
</dd>
<dt>
<em>deliveryCount</em> (integer)
</dt>
<dd>
<p>
  The total number of deliveries that have traversed this link.
</p>
</dd>
</dl>
<h4><a name="_router_address"></a>3.5.4. router.address</h4>
<p>AMQP address managed by the router.</p>
<p>Operations allowed: <code>READ</code></p>
<dl>
<dt>
<em>distribution</em> (One of [<em>flood</em>, <em>multicast</em>, <em>closest</em>, <em>balanced</em>, <em>linkBalanced</em>])
</dt>
<dd>
<p>
  Forwarding treatment for the address: flood - messages delivered to all subscribers along all available paths (this will cause duplicate deliveries if there are redundant paths); multi - one copy of each message delivered to all subscribers; anyClosest - messages delivered to only the closest subscriber; anyBalanced - messages delivered to one subscriber with load balanced across subscribers; linkBalanced - for link-routing, link attaches balanced across destinations.
</p>
</dd>
<dt>
<em>inProcess</em> (integer)
</dt>
<dd>
<p>
  The number of in-process subscribers for this address
</p>
</dd>
<dt>
<em>subscriberCount</em> (integer)
</dt>
<dd>
<p>
  The number of local subscribers for this address (i.e. attached to this router)
</p>
</dd>
<dt>
<em>remoteCount</em> (integer)
</dt>
<dd>
<p>
  The number of remote routers that have at least one subscriber to this address
</p>
</dd>
<dt>
<em>containerCount</em> (integer)
</dt>
<dd>
<p>
  The number of attached containers that serve this route address
</p>
</dd>
<dt>
<em>deliveriesIngress</em> (integer)
</dt>
<dd>
<p>
  The number of deliveries to this address that entered the router network on this router
</p>
</dd>
<dt>
<em>deliveriesEgress</em> (integer)
</dt>
<dd>
<p>
  The number of deliveries to this address that exited the router network on this router
</p>
</dd>
<dt>
<em>deliveriesTransit</em> (integer)
</dt>
<dd>
<p>
  The number of deliveries to this address that transited this router to another router
</p>
</dd>
<dt>
<em>deliveriesToContainer</em> (integer)
</dt>
<dd>
<p>
  The number of deliveries to this address that were given to an in-process subscriber
</p>
</dd>
<dt>
<em>deliveriesFromContainer</em> (integer)
</dt>
<dd>
<p>
  The number of deliveries to this address that were originated from an in-process entity
</p>
</dd>
<dt>
<em>key</em> (string)
</dt>
<dd>
<p>
  Internal unique (to this router) key to identify the address
</p>
</dd>
<dt>
<em>remoteHostRouters</em> (list)
</dt>
<dd>
<p>
  List of remote routers on which there is a destination for this address.
</p>
</dd>
<dt>
<em>transitOutstanding</em> (list)
</dt>
<dd>
<p>
  List of numbers of outstanding deliveries across a transit (inter-router) link for this address.  This is for balanced distribution only.
</p>
</dd>
<dt>
<em>trackedDeliveries</em> (integer)
</dt>
<dd>
<p>
  Number of transit deliveries being tracked for this address (for balanced distribution).
</p>
</dd>
</dl>
<h4><a name="_router_node"></a>3.5.5. router.node</h4>
<p>Remote router node connected to this router.</p>
<p>Operations allowed: <code>READ</code></p>
<dl>
<dt>
<em>id</em> (string)
</dt>
<dd>
<p>
  Remote node identifier.
</p>
</dd>
<dt>
<em>instance</em> (integer)
</dt>
<dd>
<p>
  Remote node boot number.
</p>
</dd>
<dt>
<em>linkState</em> (list)
</dt>
<dd>
<p>
  List of remote node&#8217;s neighbours.
</p>
</dd>
<dt>
<em>nextHop</em> (string)
</dt>
<dd>
<p>
  Neighbour ID of next hop to remote node from here.
</p>
</dd>
<dt>
<em>validOrigins</em> (list)
</dt>
<dd>
<p>
  List of valid origin nodes for messages arriving via the re mote node, used for duplicate elimination in redundant networks.
</p>
</dd>
<dt>
<em>address</em> (string)
</dt>
<dd>
<p>
  Address of the remote node
</p>
</dd>
<dt>
<em>routerLink</em> (entityId)
</dt>
<dd>
<p>
  Local link to remote node
</p>
</dd>
<dt>
<em>cost</em> (integer)
</dt>
<dd>
<p>
  Reachability cost
</p>
</dd>
</dl>
<h4><a name="_connection"></a>3.5.6. connection</h4>
<p>Connections to the router&#8217;s container.</p>
<p>Operations allowed: <code>READ</code></p>
<dl>
<dt>
<em>container</em> (string)
</dt>
<dd>
<p>
  The container for this connection
</p>
</dd>
<dt>
<em>opened</em> (boolean)
</dt>
<dd>
<p>
  The connection has been opened (i.e. AMQP OPEN)
</p>
</dd>
<dt>
<em>host</em> (string)
</dt>
<dd>
<p>
  IP address and port number in the form addr:port.
</p>
</dd>
<dt>
<em>dir</em> (One of [<em>in</em>, <em>out</em>])
</dt>
<dd>
<p>
  Direction of connection establishment in or out of the router.
</p>
</dd>
<dt>
<em>role</em> (string)
</dt>
<dt>
<em>isAuthenticated</em> (boolean)
</dt>
<dd>
<p>
  Indicates whether the identity of the connection&#8217;s user is authentic.
</p>
</dd>
<dt>
<em>isEncrypted</em> (boolean)
</dt>
<dd>
<p>
  Indicates whether the connection content is encrypted.
</p>
</dd>
<dt>
<em>sasl</em> (string)
</dt>
<dd>
<p>
  SASL mechanism in effect for authentication.
</p>
</dd>
<dt>
<em>user</em> (string)
</dt>
<dd>
<p>
  Identity of the authenticated user.
</p>
</dd>
<dt>
<em>ssl</em> (boolean)
</dt>
<dd>
<p>
  True iff SSL/TLS is in effect for this connection.
</p>
</dd>
<dt>
<em>sslProto</em> (string)
</dt>
<dd>
<p>
  SSL protocol name
</p>
</dd>
<dt>
<em>sslCipher</em> (string)
</dt>
<dd>
<p>
  SSL cipher name
</p>
</dd>
<dt>
<em>sslSsf</em> (integer)
</dt>
<dd>
<p>
  SSL strength factor in effect
</p>
</dd>
<dt>
<em>properties</em> (map)
</dt>
<dd>
<p>
  Connection properties supplied by the peer.
</p>
</dd>
</dl>
<h4><a name="_allocator"></a>3.5.7. allocator</h4>
<p>Memory allocation pool.</p>
<p>Operations allowed: <code>READ</code></p>
<dl>
<dt>
<em>typeName</em> (string)
</dt>
<dt>
<em>typeSize</em> (integer)
</dt>
<dt>
<em>transferBatchSize</em> (integer)
</dt>
<dt>
<em>localFreeListMax</em> (integer)
</dt>
<dt>
<em>globalFreeListMax</em> (integer)
</dt>
<dt>
<em>totalAllocFromHeap</em> (integer)
</dt>
<dt>
<em>totalFreeToHeap</em> (integer)
</dt>
<dt>
<em>heldByThreads</em> (integer)
</dt>
<dt>
<em>batchesRebalancedToThreads</em> (integer)
</dt>
<dt>
<em>batchesRebalancedToGlobal</em> (integer)
</dt>
<dd>
<p>
=== policyStats
</p>
</dd>
</dl>
<p>Per application connection and access statistics.</p>
<p>Operations allowed: <code>READ</code></p>
<dl>
<dt>
<em>applicationName</em> (string)
</dt>
<dd>
<p>
  The application name.
</p>
</dd>
<dt>
<em>connectionsApproved</em> (integer)
</dt>
<dt>
<em>connectionsDenied</em> (integer)
</dt>
<dt>
<em>connectionsCurrent</em> (integer)
</dt>
<dt>
<em>perUserState</em> (map)
</dt>
<dd>
<p>
  A map where the key is the authenticated user name and the value is a list of the user&#8217;s connections.
</p>
</dd>
<dt>
<em>perHostState</em> (map)
</dt>
<dd>
<p>
  A map where the key is the host name and the value is a list of the host&#8217;s connections.
</p>
</dd>
<dt>
<em>sessionDenied</em> (integer)
</dt>
<dt>
<em>senderDenied</em> (integer)
</dt>
<dt>
<em>receiverDenied</em> (integer)
</dt>
<dd>
<p>
== Management Operations
</p>
</dd>
</dl>
<p>The <em>qdstat(8)</em> and <em>qdmanage(8)</em> tools allow you to view or modify management entity
attributes. They work by invoking <strong>management operations</strong>. You can invoke these operations
from any AMQP client by sending a message with the appropriate properties and body to the
<em>$management</em> address. The message should have a <em>reply-to</em> address indicating where the
response should be sent.</p>
<h4><a name="_operations_for_all_entity_types"></a>3.5.8. Operations for all entity types</h4>
<h5><a name="_operation_read"></a>Operation READ</h5>
<p>Read attributes of a single entity</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>type</em> (string)
</dt>
<dd>
<p>
  Type of desired entity.
</p>
</dd>
<dt>
<em>name</em> (string)
</dt>
<dd>
<p>
  Name of desired entity. Must supply name or identity.
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Identity of desired entity. Must supply name or identity.
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>Attributes of the entity</p>
<h5><a name="_operation_create"></a>Operation CREATE</h5>
<p>Create a new entity.</p>
<p><b>Request body (map, required)</b><br>Attributes for the new entity. Can include name and/or type.</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>type</em> (string, required)
</dt>
<dd>
<p>
  Type of new entity.
</p>
</dd>
<dt>
<em>name</em> (string)
</dt>
<dd>
<p>
  Name of new entity. Optional, defaults to identity.
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>Attributes of the entity</p>
<h5><a name="_operation_update"></a>Operation UPDATE</h5>
<p>Update attributes of an entity</p>
<p><b>Request body (map)</b><br>Attributes to update for the entity. Can include name or identity.</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>type</em> (string)
</dt>
<dd>
<p>
  Type of desired entity.
</p>
</dd>
<dt>
<em>name</em> (string)
</dt>
<dd>
<p>
  Name of desired entity. Must supply name or identity.
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Identity of desired entity. Must supply name or identity.
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>Updated attributes of the entity</p>
<h5><a name="_operation_delete"></a>Operation DELETE</h5>
<p>Delete an entity</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>type</em> (string)
</dt>
<dd>
<p>
  Type of desired entity.
</p>
</dd>
<dt>
<em>name</em> (string)
</dt>
<dd>
<p>
  Name of desired entity. Must supply name or identity.
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Identity of desired entity. Must supply name or identity.
</p>
</dd>
</dl>
<h4><a name="_operations_for_em_org_amqp_management_em_entity_type"></a>3.5.9. Operations for <em>org.amqp.management</em> entity type</h4>
<h5><a name="_operation_get_types_2"></a>Operation GET-TYPES</h5>
<p>Get the set of entity types and their inheritance relationships</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>entityType</em> (string)
</dt>
<dd>
<p>
  If set, restrict query results to entities that extend (directly or indirectly) this type
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>A map where each key is an entity type name (string) and the corresponding value is the list of the entity types (strings) that it extends.</p>
<h5><a name="_operation_get_attributes_2"></a>Operation GET-ATTRIBUTES</h5>
<p>Get the set of entity types and the annotations they implement</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>entityType</em> (string)
</dt>
<dd>
<p>
  If set, restrict query results to entities that extend (directly or indirectly) this type
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>A map where each key is an entity type name (string) and the corresponding value is a list (of strings) of attributes on that entity type.</p>
<h5><a name="_operation_get_operations_2"></a>Operation GET-OPERATIONS</h5>
<p>Get the set of entity types and the operations they support</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>entityType</em> (string)
</dt>
<dd>
<p>
  If set, restrict query results to entities that extend (directly or indirectly) this type
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>A map where each key is an entity type name (string) and the corresponding value is the list of operation names (strings) that it supports.</p>
<h5><a name="_operation_get_annotations_2"></a>Operation GET-ANNOTATIONS</h5>
<p><b>Request properties</b></p><dl>
<dt>
<em>entityType</em> (string)
</dt>
<dd>
<p>
  If set, restrict query results to entities that extend (directly or indirectly) this type
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>A map where each key is an entity type name (string) and the corresponding value is the list of annotations (strings) that it  implements.</p>
<h5><a name="_operation_query_2"></a>Operation QUERY</h5>
<p>Query for attribute values of multiple entities.</p>
<p><b>Request body (map)</b><br>A map containing the key <code>attributeNames</code> with value a list of (string) attribute names to return. If the list or the map is empty or the body is missing all attributes are returned.</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>count</em> (integer)
</dt>
<dd>
<p>
  If set, specifies the number of entries from the result set to return. If not set return all from <code>offset</code>
</p>
</dd>
<dt>
<em>entityType</em> (string)
</dt>
<dd>
<p>
  If set, restrict query results to entities that extend (directly or indirectly) this type
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
<dt>
<em>offset</em> (integer)
</dt>
<dd>
<p>
  If set, specifies the number of the first element of the result set to be returned.
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>A map with two entries. <code>attributeNames</code> is a list of the attribute names returned. <code>results</code> is a list of lists each containing the attribute values for a single entity in the same order as the names in the <code>attributeNames</code> entry. If an attribute name is not applicable for an entity then the corresponding value is <code>null</code></p>
<p><b>Response properties</b></p><dl>
<dt>
<em>count</em> (integer)
</dt>
<dd>
<p>
  Number of results returned
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<h5><a name="_operation_get_mgmt_nodes_2"></a>Operation GET-MGMT-NODES</h5>
<p>Get the addresses of all management nodes known to this router</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (list)</b><br>A list of addresses (strings) of management nodes known to this management node.</p>
<h4><a name="_operations_for_em_management_em_entity_type"></a>3.5.10. Operations for <em>management</em> entity type</h4>
<h5><a name="_operation_get_schema_json_2"></a>Operation GET-SCHEMA-JSON</h5>
<p>Get the qdrouterd schema for this router in JSON format</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>indent</em> (integer)
</dt>
<dd>
<p>
  Number of spaces to indent the formatted result. If not specified, the result is in minimal format, no unnecessary spaces or newlines.
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (string)</b><br>The qdrouter schema as a JSON string.</p>
<h5><a name="_operation_get_log_2"></a>Operation GET-LOG</h5>
<p>Get recent log entries from the router.</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>limit</em> (integer)
</dt>
<dd>
<p>
  Maximum number of log entries to get.
</p>
</dd>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (string)</b><br>A list of log entries where each entry is a list of: module name(string), level name(string), message text(string), file name(string or None), line number(integer or None) , timestamp(integer)</p>
<h5><a name="_operation_get_schema_2"></a>Operation GET-SCHEMA</h5>
<p>Get the qdrouterd schema for this router in AMQP map format</p>
<p><b>Request properties</b></p><dl>
<dt>
<em>identity</em> (string)
</dt>
<dd>
<p>
  Set to the value <code>self</code>
</p>
</dd>
</dl>
<p><b>Response body (map)</b><br>The qdrouter schema as a map.</p>
<hr>
<h2><a name="console"></a>4. Console</h2>
<h3><a name="console-overview"></a>4.1. Console overview</h3>
<p>The console is an HTML based web site that displays information about a qpid dispatch router network.</p>
<p>The console requires an HTML web server that can serve static html, javascript, style sheets, and images.</p>
<p>The console only provides limited information about the clients that are attached to the router network and is therfore more appropriate for administrators needing to know the layout and health of the router network.</p>
<h3><a name="console-installation"></a>4.2. Console installation</h3>
<h4><a name="prerequisites"></a>4.2.1. Prerequisites</h4>
<p>The following need to be installed before running a console:</p>
<ul>
<li>
<p>
One or more dispatch routers. See the documentation for the dispatch
router for help in starting a router network.
</p>
</li>
<li>
<p>
A websockets to tcp proxy.
</p>
</li>
<li>
<p>
A web server. This can be any server capable of serving static
html/js/css/image files.
</p>
</li>
</ul>
<p>To install a websockets to tcp proxy:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>sudo dnf install python-websockify
websockify localhost:5673 localhost:5672</code></pre>
</td></tr></table>
<p>This will start the proxy listening to ws traffic on port 5673 and
translating it to tcp on port 5672. One of the routers in the network
needs to have a listener configured on port 5672. That listener&#8217;s role
should be <em>normal</em>. For example:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code>listener {
   host: 0.0.0.0
   role: normal
   port: amqp
   saslMechanisms: ANONYMOUS
}</code></pre>
</td></tr></table>
<h4><a name="the-console-files"></a>4.2.2. The console files</h4>
<p>The files for the console are located under the console/stand-alone
directory in the source tree
*  <em>index.html</em>
*  <em>plugin/</em></p>
<p>Copy these files to a directory under the the html or webapps directory
of your web server. For example, for apache tomcat the files should be
under webapps/dispatch. Then the console is available as <em>http://localhost:8080/dispatch</em></p>
<h3><a name="console-operation"></a>4.3. Console operation</h3>
<h4><a name="logging-in-to-a-router-network"></a>4.3.1. Logging in to a router network</h4>
<p><img src="console_login.png" style="border-width: 0;" alt="image"></p>
<p>Enter the address of the websockets to tcp proxy that is connected to a router in the network.</p>
<p>The Autostart checkbox, when checked, will automatically log in with the previous host:port the next time you start the console.</p>
<h4><a name="overview-page"></a>4.3.2. Overview page</h4>
<p><img src="console_overview.png" style="border-width: 0;" alt="image"></p>
<p>On the overview page, aggregate information about routers, addresses, and connections is displayed.</p>
<h4><a name="topology-page"></a>4.3.3. Topology page</h4>
<p><img src="console_topology.png" style="border-width: 0;" alt="image"></p>
<p>This page displays the router network in a graphical form showing how the routers are connected and information about the individual routers and links.</p>
<h4><a name="list-page"></a>4.3.4. List page</h4>
<p><img src="console_entity.png" style="border-width: 0;" alt="image"></p>
<p>Displays detailed information about entities such as routers, links, addresses, memory.</p>
<h4><a name="charts-page"></a>4.3.5. Charts page</h4>
<p><img src="console_charts.png" style="border-width: 0;" alt="image"></p>
<p>This page displays graphs of numeric values that are on the list page.</p>
<h4><a name="schema-page"></a>4.3.6. Schema page</h4>
<p><img src="console_schema.png" style="border-width: 0;" alt="image"></p>
<p>This page displays the json schema that is used to manage the router network.</p>
