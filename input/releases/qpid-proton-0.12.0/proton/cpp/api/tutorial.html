<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Qpid Proton C++ API: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qpid Proton C++ API
   &#160;<span id="projectnumber">0.12.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a brief tutorial that will walk you through the fundamentals of building messaging applications in incremental steps.</p>
<p>There are further examples, in addition the ones mentioned in the tutorial.</p>
<p>Some of the examples require an AMQP <em>broker</em> that can receive, store and send messages. <a class="el" href="broker_8hpp-example.html">broker.hpp</a> and <a class="el" href="broker_8cpp-example.html">broker.cpp</a> define a simple example broker. Run without arguments it listens on <code>0.0.0.0:5672</code>, the standard AMQP port on all network interfaces. To use a different port or network interface: </p><pre class="fragment">broker -a &lt;host&gt;:&lt;port&gt;
</pre><p>Instead of the example broker, you can use any AMQP 1.0 compliant broker. You must configure your broker to have a queue (or topic) named "examples".</p>
<p>The <code>helloworld</code> examples take an optional URL argument. The other examples take an option <code>-a URL</code>. A URL looks like: </p><pre class="fragment">HOST:PORT/ADDRESS
</pre><p>It usually defaults to <code>127.0.0.1:5672/examples</code>, but you can change this if your broker is on a different host or port, or you want to use a different queue or topic name (the ADDRESS part of the URL). URL details are at <code><a class="el" href="classproton_1_1url.html" title="A proton URL. ">proton::url</a></code></p>
<p>The first part of the tutorial uses the <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links. ">proton::container</a></code>, later we will show some of the same examples implemented using the <code><a class="el" href="classproton_1_1connection__engine.html" title="An interface for connection-oriented IO integration. ">proton::connection_engine</a></code>. Most of the code is the same for either approach.</p>
<h2>Hello World! </h2>
<p>Tradition dictates that we start with hello world! This example sends a message to a broker and the receives the same message back to demonstrate sending and receiving. In a realistic system the sender and receiver would normally be in different processes. The complete example is <a class="el" href="helloworld_8cpp-example.html">helloworld.cpp</a></p>
<p>We will include the following classes: <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links. ">proton::container</a></code> runs an event loop which dispatches events to a <code><a class="el" href="classproton_1_1handler.html" title="Callback functions for handling proton events. ">proton::handler</a></code>. This allows a <em>reactive</em> style of programming which is well suited to messaging applications. <code><a class="el" href="classproton_1_1url.html" title="A proton URL. ">proton::url</a></code> is a simple parser for the URL format mentioned above.</p>
<p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;proton/container.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;proton/event.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;proton/handler.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;proton/url.hpp&quot;</span></div>
</div><!-- fragment --></p>
<p>We will define a class <code>hello_world</code> which is a subclass of <code><a class="el" href="classproton_1_1handler.html" title="Callback functions for handling proton events. ">proton::handler</a></code> and over-rides functions to handle the events of interest in sending and receiving a message.</p>
<p><div class="fragment"><div class="line"><span class="keyword">class </span>hello_world : <span class="keyword">public</span> <a class="code" href="classproton_1_1handler.html">proton::handler</a> {</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classproton_1_1url.html">proton::url</a> url;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    hello_world(<span class="keyword">const</span> <a class="code" href="classproton_1_1url.html">proton::url</a>&amp; u) : url(u) {}</div>
</div><!-- fragment --></p>
<p><code>on_start()</code> is called when the event loop first starts. We handle that by establishing a connection and creating a sender and a receiver.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_start(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        <a class="code" href="classproton_1_1connection.html">proton::connection</a> conn = e.<a class="code" href="classproton_1_1event.html#abad30f82e0c40d60df954b95b60dbf14">container</a>().<a class="code" href="classproton_1_1container.html#a544f214bbb007ed7c2331cbebb60c283">connect</a>(url);</div>
<div class="line">        conn.<a class="code" href="classproton_1_1connection.html#af1fb4d28f91a33fb7c8a73a4083f6745">open_receiver</a>(url.<a class="code" href="classproton_1_1url.html#a9b67b266207227062c7a2961ef85293a">path</a>());</div>
<div class="line">        conn.<a class="code" href="classproton_1_1connection.html#a7ebd6d1b79102078ccdb1e07b1cd90f7">open_sender</a>(url.<a class="code" href="classproton_1_1url.html#a9b67b266207227062c7a2961ef85293a">path</a>());</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p><code>on_sendable()</code> is called when message can be transferred over the associated sender link to the remote peer. We create a <code><a class="el" href="classproton_1_1message.html" title="An AMQP message. ">proton::message</a></code>, set the message body to <code>"Hello World!"</code> and send the message. Then we close the sender as we only want to send one message. Closing the sender will prevent further calls to <code>on_sendable()</code>.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_sendable(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        <a class="code" href="classproton_1_1message.html">proton::message</a> m(<span class="stringliteral">&quot;Hello World!&quot;</span>);</div>
<div class="line">        e.<a class="code" href="classproton_1_1event.html#ab414c60355e9d9973b3968c2e495f4ef">sender</a>().<a class="code" href="classproton_1_1sender.html#aefaf5ace497245ca76c6c9d629ae7bee">send</a>(m);</div>
<div class="line">        e.<a class="code" href="classproton_1_1event.html#ab414c60355e9d9973b3968c2e495f4ef">sender</a>().<a class="code" href="classproton_1_1link.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p><code>on_message()</code> is called when a message is received. We just print the body of the message and close the connection, as we only want one message</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        std::cout &lt;&lt; e.<a class="code" href="classproton_1_1event.html#acf106181dfb627b4cecdab1ecf776dba">message</a>().<a class="code" href="classproton_1_1message.html#adec309c753bff891f9837bd9977b8440">body</a>() &lt;&lt; std::endl;</div>
<div class="line">        e.<a class="code" href="classproton_1_1event.html#a30da3a4aab03af60b45861d83f49ca1b">connection</a>().<a class="code" href="classproton_1_1connection.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>The message body is a <code><a class="el" href="classproton_1_1value.html" title="A holder for an AMQP value. ">proton::value</a></code>, see the documentation for more on how to extract the message body as type-safe C++ values.</p>
<p>Our <code>main</code> function creates an instance of the <code>hello_world</code> handler and a <a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links. ">proton::container</a> using that handler. Calling <code><a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1" title="Start processing events. ">proton::container::run</a></code> sets things in motion and returns when we close the connection as there is nothing further to do. It may throw an exception, which will be a subclass of <code><a class="el" href="structproton_1_1error.html" title="The base proton error. ">proton::error</a></code>. That in turn is a subclass of <code>std::exception</code>.</p>
<p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::string url = argc &gt; 1 ? argv[1] : <span class="stringliteral">&quot;127.0.0.1:5672/examples&quot;</span>;</div>
<div class="line"></div>
<div class="line">        hello_world hw(url);</div>
<div class="line">        <a class="code" href="classproton_1_1container.html">proton::container</a>(hw).<a class="code" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1">run</a>();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<h2>Hello World, Direct! </h2>
<p>Though often used in conjunction with a broker, AMQP does not <em>require</em> this. It also allows senders and receivers to communicate directly if desired.</p>
<p>We will modify our example to send a message directly to itself. This is a bit contrived but illustrates both sides of the direct send/receive scenario. Full code at <a class="el" href="helloworld_direct_8cpp-example.html">helloworld_direct.cpp</a></p>
<p>The first difference, is that rather than creating a receiver on the same connection as our sender, we listen for incoming connections by invoking the <code><a class="el" href="classproton_1_1container.html#ab5a976cc459568f13da407a038591ca2" title="Listen on url for incoming connections. ">proton::container::listen()</a></code> method on the container.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_start(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        acceptor = e.<a class="code" href="classproton_1_1event.html#abad30f82e0c40d60df954b95b60dbf14">container</a>().<a class="code" href="classproton_1_1container.html#ab5a976cc459568f13da407a038591ca2">listen</a>(url);</div>
<div class="line">        e.<a class="code" href="classproton_1_1event.html#abad30f82e0c40d60df954b95b60dbf14">container</a>().<a class="code" href="classproton_1_1container.html#ae8a3a769f9c424c05993f6d137376c76">open_sender</a>(url);</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>As we only need then to initiate one link, the sender, we can do that by passing in a url rather than an existing connection, and the connection will also be automatically established for us.</p>
<p>We send the message in response to the <code>on_sendable()</code> callback and print the message out in response to the <code>on_message()</code> callback exactly as before.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_sendable(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        <a class="code" href="classproton_1_1message.html">proton::message</a> m(<span class="stringliteral">&quot;Hello World!&quot;</span>);</div>
<div class="line">        e.<a class="code" href="classproton_1_1event.html#ab414c60355e9d9973b3968c2e495f4ef">sender</a>().<a class="code" href="classproton_1_1sender.html#aefaf5ace497245ca76c6c9d629ae7bee">send</a>(m);</div>
<div class="line">        e.<a class="code" href="classproton_1_1event.html#ab414c60355e9d9973b3968c2e495f4ef">sender</a>().<a class="code" href="classproton_1_1link.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        std::cout &lt;&lt; e.<a class="code" href="classproton_1_1event.html#acf106181dfb627b4cecdab1ecf776dba">message</a>().<a class="code" href="classproton_1_1message.html#adec309c753bff891f9837bd9977b8440">body</a>() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>However we also handle two new events. We now close the connection from the senders side once the message has been accepted. The acceptance of the message is an indication of successful transfer to the peer. We are notified of that event through the <code>on_delivery_accept()</code> callback.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_delivery_accept(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        e.<a class="code" href="classproton_1_1event.html#a30da3a4aab03af60b45861d83f49ca1b">connection</a>().<a class="code" href="classproton_1_1connection.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>Then, once the connection has been closed, of which we are notified through the <code>on_connection_close()</code> callback, we stop accepting incoming connections at which point there is no work to be done and the event loop exits, and the run() method will return.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_connection_close(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        acceptor.close();</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>So now we have our example working without a broker involved!</p>
<p>Note that for this example we pick an "unusual" port 8888 since we are talking to ourselves rather than a broker.</p>
<p><div class="fragment"><div class="line">        std::string url = argc &gt; 1 ? argv[1] : <span class="stringliteral">&quot;127.0.0.1:8888/examples&quot;</span>;</div>
</div><!-- fragment --></p>
<h2>Asynchronous Send and Receive </h2>
<p>Of course, these <code>HelloWorld!</code> examples are very artificial, communicating as they do over a network connection but with the same process. A more realistic example involves communication between separate processes (which could indeed be running on completely separate machines).</p>
<p>Let's separate the sender from the receiver, and transfer more than a single message between them.</p>
<p>We'll start with a simple sender <a class="el" href="simple_send_8cpp-example.html">simple_send.cpp</a>.</p>
<p>As with the previous example, we define the application logic in a class that handles events. Because we are transferring more than one message, we need to keep track of how many we have sent. We'll use a <code>sent</code> member variable for that. The <code>total</code> member variable will hold the number of messages we want to send.</p>
<p><div class="fragment"><div class="line"><span class="keyword">class </span>simple_send : <span class="keyword">public</span> <a class="code" href="classproton_1_1handler.html">proton::handler</a> {</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classproton_1_1url.html">proton::url</a> url;</div>
<div class="line">    <a class="code" href="classproton_1_1sender.html">proton::sender</a> sender;</div>
<div class="line">    <span class="keywordtype">int</span> sent;</div>
<div class="line">    <span class="keywordtype">int</span> confirmed;</div>
<div class="line">    <span class="keywordtype">int</span> total;</div>
</div><!-- fragment --></p>
<p>As before, we use the <code>on_start()</code> event to establish our sender link over which we will transfer messages.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_start(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        sender = e.<a class="code" href="classproton_1_1event.html#abad30f82e0c40d60df954b95b60dbf14">container</a>().<a class="code" href="classproton_1_1container.html#ae8a3a769f9c424c05993f6d137376c76">open_sender</a>(url);</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>AMQP defines a credit-based flow control mechanism. Flow control allows the receiver to control how many messages it is prepared to receive at a given time and thus prevents any component being overwhelmed by the number of messages it is sent.</p>
<p>In the <code>on_sendable()</code> callback, we check that our sender has credit before sending messages. We also check that we haven't already sent the required number of messages.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_sendable(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        <a class="code" href="classproton_1_1sender.html">proton::sender</a> sender = e.<a class="code" href="classproton_1_1event.html#ab414c60355e9d9973b3968c2e495f4ef">sender</a>();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">while</span> (sender.<a class="code" href="classproton_1_1link.html#a75360c7515b9f569871c5ea953286649">credit</a>() &amp;&amp; sent &lt; total) {</div>
<div class="line">            <a class="code" href="classproton_1_1message.html">proton::message</a> msg;</div>
<div class="line">            std::map&lt;std::string, int&gt; m;</div>
<div class="line">            m[<span class="stringliteral">&quot;sequence&quot;</span>] = sent + 1;</div>
<div class="line">            </div>
<div class="line">            msg.id(sent + 1);</div>
<div class="line">            msg.<a class="code" href="classproton_1_1message.html#adec309c753bff891f9837bd9977b8440">body</a>(m);</div>
<div class="line"></div>
<div class="line">            sender.<a class="code" href="classproton_1_1sender.html#aefaf5ace497245ca76c6c9d629ae7bee">send</a>(msg);</div>
<div class="line">            sent++;</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>The <code><a class="el" href="classproton_1_1sender.html#aefaf5ace497245ca76c6c9d629ae7bee" title="Send a message on the link. ">proton::sender::send()</a></code> call above is asynchronous. When it returns the message has not yet actually been transferred across the network to the receiver. By handling the <code>on_accepted()</code> event, we can get notified when the receiver has received and accepted the message. In our example we use this event to track the confirmation of the messages we have sent. We only close the connection and exit when the receiver has received all the messages we wanted to send.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_delivery_accept(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        confirmed++;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (confirmed == total) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;all messages confirmed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            e.<a class="code" href="classproton_1_1event.html#a30da3a4aab03af60b45861d83f49ca1b">connection</a>().<a class="code" href="classproton_1_1connection.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>If we are disconnected after a message is sent and before it has been confirmed by the receiver, it is said to be <code>in doubt</code>. We don't know whether or not it was received. In this example, we will handle that by resending any in-doubt messages. This is known as an 'at-least-once' guarantee, since each message should eventually be received at least once, though a given message may be received more than once (i.e. duplicates are possible). In the <code>on_disconnected()</code> callback, we reset the sent count to reflect only those that have been confirmed. The library will automatically try to reconnect for us, and when our sender is sendable again, we can restart from the point we know the receiver got to.</p>
<p><div class="fragment"><div class="line">}</div>
</div><!-- fragment --></p>
<p>Now let's look at the corresponding receiver <a class="el" href="simple_recv_8cpp-example.html">simple_recv.cpp</a></p>
<p>This time we'll use an <code>expected</code> member variable for for the number of messages we expect and a <code>received</code> variable to count how many we have received so far.</p>
<p><div class="fragment"><div class="line"><span class="keyword">class </span>simple_recv : <span class="keyword">public</span> <a class="code" href="classproton_1_1handler.html">proton::handler</a> {</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classproton_1_1url.html">proton::url</a> url;</div>
<div class="line">    <a class="code" href="classproton_1_1receiver.html">proton::receiver</a> receiver;</div>
<div class="line">    uint64_t expected;</div>
<div class="line">    uint64_t received;</div>
</div><!-- fragment --></p>
<p>We handle <code>on_start()</code> by creating our receiver, much like we did for the sender.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_start(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        receiver = e.<a class="code" href="classproton_1_1event.html#abad30f82e0c40d60df954b95b60dbf14">container</a>().<a class="code" href="classproton_1_1container.html#a9d15beec9803fa359017bb6263cef249">open_receiver</a>(url);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;simple_recv listening on &quot;</span> &lt;&lt; url &lt;&lt; std::endl;</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>We also handle the <code>on_message()</code> event for received messages and print the message out as in the <code>Hello World!</code> examples. However we add some logic to allow the receiver to wait for a given number of messages, then to close the connection and exit. We also add some logic to check for and ignore duplicates, using a simple sequential id scheme.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        <a class="code" href="classproton_1_1message.html">proton::message</a>&amp; msg = e.<a class="code" href="classproton_1_1event.html#acf106181dfb627b4cecdab1ecf776dba">message</a>();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (msg.id().get&lt;uint64_t&gt;() &lt; received) {</div>
<div class="line">            <span class="keywordflow">return</span>; <span class="comment">// Ignore duplicate</span></div>
<div class="line">        }</div>
</div><!-- fragment --></p>
<h2>Direct Send and Receive </h2>
<p>Sending between these two examples requires an intermediary broker since neither accepts incoming connections. AMQP allows us to send messages directly between two processes. In that case one or other of the processes needs to accept incoming connections. Let's create a modified version of the receiving example that does this with <a class="el" href="direct_recv_8cpp-example.html">direct_recv.cpp</a></p>
<p>There are only two differences here. Instead of initiating a link (and implicitly a connection), we listen for incoming connections.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_start(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        acceptor = e.<a class="code" href="classproton_1_1event.html#abad30f82e0c40d60df954b95b60dbf14">container</a>().<a class="code" href="classproton_1_1container.html#ab5a976cc459568f13da407a038591ca2">listen</a>(url);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;direct_recv listening on &quot;</span> &lt;&lt; url &lt;&lt; std::endl;</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>When we have received all the expected messages, we then stop listening for incoming connections by closing the acceptor object.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        <a class="code" href="classproton_1_1message.html">proton::message</a>&amp; msg = e.<a class="code" href="classproton_1_1event.html#acf106181dfb627b4cecdab1ecf776dba">message</a>();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (msg.id().get&lt;uint64_t&gt;() &lt; received) {</div>
<div class="line">            <span class="keywordflow">return</span>; <span class="comment">// Ignore duplicate</span></div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (expected == 0 || received &lt; expected) {</div>
<div class="line">            std::cout &lt;&lt; msg.<a class="code" href="classproton_1_1message.html#adec309c753bff891f9837bd9977b8440">body</a>() &lt;&lt; std::endl;</div>
<div class="line">            received++;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (received == expected) {</div>
<div class="line">            e.<a class="code" href="classproton_1_1event.html#a278bcf92ab462ffccafdaacb8b009471">receiver</a>().<a class="code" href="classproton_1_1link.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line">            e.<a class="code" href="classproton_1_1event.html#a30da3a4aab03af60b45861d83f49ca1b">connection</a>().<a class="code" href="classproton_1_1connection.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!!acceptor) acceptor.close();</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>You can use the <a class="el" href="simple_send_8cpp-example.html">simple_send.cpp</a> example to send to this receiver directly. (Note: you will need to stop any broker that is listening on the 5672 port, or else change the port used by specifying a different address to each example via the -a command line switch).</p>
<p>We can also modify the sender to allow the original receiver to connect to it, in <a class="el" href="direct_send_8cpp-example.html">direct_send.cpp</a>. Again that just requires two modifications:</p>
<p>As with the modified receiver, instead of initiating establishment of a link, we listen for incoming connections.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_start(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        acceptor = e.<a class="code" href="classproton_1_1event.html#abad30f82e0c40d60df954b95b60dbf14">container</a>().<a class="code" href="classproton_1_1container.html#ab5a976cc459568f13da407a038591ca2">listen</a>(url);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;direct_send listening on &quot;</span> &lt;&lt; url &lt;&lt; std::endl;</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>When we have received confirmation of all the messages we sent, we can close the acceptor in order to exit.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_delivery_accept(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        confirmed++;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (confirmed == total) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;all messages confirmed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">            e.<a class="code" href="classproton_1_1event.html#a30da3a4aab03af60b45861d83f49ca1b">connection</a>().<a class="code" href="classproton_1_1connection.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line">            acceptor.close();</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>To try this modified sender, run the original <a class="el" href="simple_recv_8cpp-example.html">simple_recv.cpp</a> against it.</p>
<p>The symmetry in the underlying AMQP that enables this is quite unique and elegant, and in reflecting this the proton API provides a flexible toolkit for implementing all sorts of interesting intermediaries (<a class="el" href="broker_8hpp-example.html">broker.hpp</a> and <a class="el" href="broker_8cpp-example.html">broker.cpp</a> provide a simple broker for testing purposes is an example of this).</p>
<h2>Request/Response </h2>
<p>A common pattern is to send a request message and expect a response message in return. AMQP has special support for this pattern. Let's have a look at a simple example. We'll start with <a class="el" href="server_8cpp-example.html">server.cpp</a>, the program that will process the request and send the response. Note that we are still using a broker in this example.</p>
<p>Our server will provide a very simple service: it will respond with the body of the request converted to uppercase.</p>
 <div class="fragment"><div class="line"><span class="keyword">class </span>server : <span class="keyword">public</span> <a class="code" href="classproton_1_1handler.html">proton::handler</a> {</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">typedef</span> std::map&lt;std::string, proton::sender&gt; sender_map;</div>
<div class="line">    <a class="code" href="classproton_1_1url.html">proton::url</a> url;</div>
<div class="line">    <a class="code" href="classproton_1_1connection.html">proton::connection</a> connection;</div>
<div class="line">    sender_map senders;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    server(<span class="keyword">const</span> std::string &amp;u) : url(u) {}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classproton_1_1handler.html#a853f861e091fdb37b69d94be1b0ea032">on_start</a>(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        connection = e.<a class="code" href="classproton_1_1event.html#abad30f82e0c40d60df954b95b60dbf14">container</a>().<a class="code" href="classproton_1_1container.html#a544f214bbb007ed7c2331cbebb60c283">connect</a>(url);</div>
<div class="line">        connection.<a class="code" href="classproton_1_1connection.html#af1fb4d28f91a33fb7c8a73a4083f6745">open_receiver</a>(url.<a class="code" href="classproton_1_1url.html#a9b67b266207227062c7a2961ef85293a">path</a>());</div>
<div class="line"></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;server connected to &quot;</span> &lt;&lt; url &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::string to_upper(<span class="keyword">const</span> std::string &amp;s) {</div>
<div class="line">        std::string uc(s);</div>
<div class="line">        <span class="keywordtype">size_t</span> l = uc.size();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;l; i++) uc[i] = std::toupper(uc[i]);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> uc;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classproton_1_1handler.html#ade01b01951064667a5a076362c5e61ef">on_message</a>(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Received &quot;</span> &lt;&lt; e.<a class="code" href="classproton_1_1event.html#acf106181dfb627b4cecdab1ecf776dba">message</a>().<a class="code" href="classproton_1_1message.html#adec309c753bff891f9837bd9977b8440">body</a>() &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        std::string reply_to = e.<a class="code" href="classproton_1_1event.html#acf106181dfb627b4cecdab1ecf776dba">message</a>().reply_to();</div>
<div class="line">        <a class="code" href="classproton_1_1message.html">proton::message</a> reply;</div>
<div class="line"></div>
<div class="line">        reply.address(reply_to);</div>
<div class="line">        reply.<a class="code" href="classproton_1_1message.html#adec309c753bff891f9837bd9977b8440">body</a>(to_upper(e.<a class="code" href="classproton_1_1event.html#acf106181dfb627b4cecdab1ecf776dba">message</a>().<a class="code" href="classproton_1_1message.html#adec309c753bff891f9837bd9977b8440">body</a>().get&lt;std::string&gt;()));</div>
<div class="line">        reply.correlation_id(e.<a class="code" href="classproton_1_1event.html#acf106181dfb627b4cecdab1ecf776dba">message</a>().correlation_id());</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!senders[reply_to]) {</div>
<div class="line">            senders[reply_to] = connection.<a class="code" href="classproton_1_1connection.html#a7ebd6d1b79102078ccdb1e07b1cd90f7">open_sender</a>(reply_to);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        senders[reply_to].<a class="code" href="classproton_1_1sender.html#aefaf5ace497245ca76c6c9d629ae7bee">send</a>(reply);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --></p>
<p>The code here is not too different from the simple receiver example. When we receive a request in <code>on_message</code> however, we look at the <code>proton::message::reply_to</code> address and create a sender with that address for the response. We'll cache the senders incase we get further requests with the same <code>reply_to</code>.</p>
<p>Now let's create a simple <a class="el" href="client_8cpp-example.html">client.cpp</a> to test this service out.</p>
<p>Our client takes a list of strings to send as requests</p>
<p><div class="fragment"><div class="line">    client(<span class="keyword">const</span> <a class="code" href="classproton_1_1url.html">proton::url</a> &amp;u, <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; r) : url(u), requests(r) {}</div>
</div><!-- fragment --></p>
<p>Since we will be sending and receiving, we create a sender and a receiver in <code>on_start</code>. Our receiver has a blank address and sets the <code>dynamic</code> flag to true, which means we expect the remote end (broker or server) to assign a unique address for us.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_start(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        sender = e.<a class="code" href="classproton_1_1event.html#abad30f82e0c40d60df954b95b60dbf14">container</a>().<a class="code" href="classproton_1_1container.html#ae8a3a769f9c424c05993f6d137376c76">open_sender</a>(url);</div>
<div class="line">        <span class="comment">// Create a receiver with a dynamically chosen unique address.</span></div>
<div class="line">        receiver = sender.<a class="code" href="classproton_1_1link.html#af13d10fc3d843719af9ff4c456330a73">connection</a>().<a class="code" href="classproton_1_1connection.html#af1fb4d28f91a33fb7c8a73a4083f6745">open_receiver</a>(<span class="stringliteral">&quot;&quot;</span>, <a class="code" href="classproton_1_1link__options.html">proton::link_options</a>().dynamic_address(<span class="keyword">true</span>));</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>Now a function to send the next request from our list of requests. We set the reply_to address to be the dynamically assigned address of our receiver.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> send_request() {</div>
<div class="line">        <a class="code" href="classproton_1_1message.html">proton::message</a> req;</div>
<div class="line">        req.<a class="code" href="classproton_1_1message.html#adec309c753bff891f9837bd9977b8440">body</a>(requests.front());</div>
<div class="line">        req.reply_to(receiver.<a class="code" href="classproton_1_1link.html#adc8d612ee69e5722919c1bc2c95df66e">remote_source</a>().<a class="code" href="classproton_1_1terminus.html#a977efa04715923ca4fa290a6ec90c830">address</a>());</div>
<div class="line"></div>
<div class="line">        sender.<a class="code" href="classproton_1_1sender.html#aefaf5ace497245ca76c6c9d629ae7bee">send</a>(req);</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>We need to use the address assigned by the broker as the <code>reply_to</code> address of our requests, so we can't send them until our receiver has been set up. To do that, we add an <code>on_link_open()</code> method to our handler class, and if the link associated with event is the receiver, we use that as the trigger to send our first request.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_link_open(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        <span class="keywordflow">if</span> (e.<a class="code" href="classproton_1_1event.html#a85f8aef2b68e7991bec0ee162f471097">link</a>() == receiver) {</div>
<div class="line">            send_request();</div>
<div class="line">        }</div>
</div><!-- fragment --></p>
<p>When we receive a reply, we send the next request.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        <span class="keywordflow">if</span> (requests.empty()) <span class="keywordflow">return</span>; <span class="comment">// Spurious extra message!</span></div>
<div class="line"></div>
<div class="line">        <a class="code" href="classproton_1_1message.html">proton::message</a>&amp; response = e.<a class="code" href="classproton_1_1event.html#acf106181dfb627b4cecdab1ecf776dba">message</a>();</div>
<div class="line"></div>
<div class="line">        std::cout &lt;&lt; requests.front() &lt;&lt; <span class="stringliteral">&quot; =&gt; &quot;</span> &lt;&lt; response.<a class="code" href="classproton_1_1message.html#adec309c753bff891f9837bd9977b8440">body</a>() &lt;&lt; std::endl;</div>
<div class="line">        requests.erase(requests.begin());</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!requests.empty()) {</div>
<div class="line">            send_request();</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            e.<a class="code" href="classproton_1_1event.html#a30da3a4aab03af60b45861d83f49ca1b">connection</a>().<a class="code" href="classproton_1_1connection.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<h2>Direct Request/Response </h2>
<p>We can avoid the intermediary process by writing a server that accepts connections directly, <a class="el" href="server_direct_8cpp-example.html">server_direct.cpp</a>. It involves the following changes to our original server:</p>
<p>Our server must generate a unique reply-to addresses for links from the client that request a dynamic address (previously this was done by the broker.) We use a simple counter.</p>
<p><div class="fragment"><div class="line">    std::string generate_address() {</div>
<div class="line">        std::ostringstream addr;</div>
<div class="line">        addr &lt;&lt; <span class="stringliteral">&quot;server&quot;</span> &lt;&lt; address_counter++;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> addr.str();</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>Next we need to handle incoming requests for links with dynamic addresses from the client. We give the link a unique address and record it in our <code>senders</code> map.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_link_open(<a class="code" href="classproton_1_1event.html">proton::event</a>&amp; e) {</div>
<div class="line">        <a class="code" href="classproton_1_1link.html">proton::link</a> link = e.<a class="code" href="classproton_1_1event.html#a85f8aef2b68e7991bec0ee162f471097">link</a>();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (!!link.<a class="code" href="classproton_1_1link.html#a0c49e11e40611be0b41bf595b6455a83">sender</a>() &amp;&amp; link.<a class="code" href="classproton_1_1link.html#adc8d612ee69e5722919c1bc2c95df66e">remote_source</a>().<a class="code" href="classproton_1_1terminus.html#ab6f99d305cf67c3a6c3d786d2b819ca8">dynamic</a>()) {</div>
<div class="line">            link.<a class="code" href="classproton_1_1link.html#a2246ba119cbaa626fb423e1ba80f84c5">local_source</a>().<a class="code" href="classproton_1_1terminus.html#a977efa04715923ca4fa290a6ec90c830">address</a>(generate_address());</div>
<div class="line">            senders[link.<a class="code" href="classproton_1_1link.html#a2246ba119cbaa626fb423e1ba80f84c5">local_source</a>().<a class="code" href="classproton_1_1terminus.html#a977efa04715923ca4fa290a6ec90c830">address</a>()] = link.<a class="code" href="classproton_1_1link.html#a0c49e11e40611be0b41bf595b6455a83">sender</a>();</div>
<div class="line">        }</div>
</div><!-- fragment --></p>
<p>Note we are interested in <em>sender</em> links above because we are implementing the server. A <em>receiver</em> link created on the client corresponds to a <em>sender</em> link on the server.</p>
<p>Finally when we receive a message we look up its <code>reply_to</code> in our senders map and send the reply.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_message(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Received &quot;</span> &lt;&lt; e.<a class="code" href="classproton_1_1event.html#acf106181dfb627b4cecdab1ecf776dba">message</a>().<a class="code" href="classproton_1_1message.html#adec309c753bff891f9837bd9977b8440">body</a>() &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        std::string reply_to = e.<a class="code" href="classproton_1_1event.html#acf106181dfb627b4cecdab1ecf776dba">message</a>().reply_to();</div>
<div class="line">        sender_map::iterator it = senders.find(reply_to);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (it == senders.end()) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;No link for reply_to: &quot;</span> &lt;&lt; reply_to &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <a class="code" href="classproton_1_1sender.html">proton::sender</a> sender = it-&gt;second;</div>
<div class="line">            <a class="code" href="classproton_1_1message.html">proton::message</a> reply;</div>
<div class="line">            </div>
<div class="line">            reply.address(reply_to);</div>
<div class="line">            reply.<a class="code" href="classproton_1_1message.html#adec309c753bff891f9837bd9977b8440">body</a>(to_upper(e.<a class="code" href="classproton_1_1event.html#acf106181dfb627b4cecdab1ecf776dba">message</a>().<a class="code" href="classproton_1_1message.html#adec309c753bff891f9837bd9977b8440">body</a>().get&lt;std::string&gt;()));</div>
<div class="line">            reply.correlation_id(e.<a class="code" href="classproton_1_1event.html#acf106181dfb627b4cecdab1ecf776dba">message</a>().correlation_id());</div>
<div class="line"></div>
<div class="line">            sender.<a class="code" href="classproton_1_1sender.html#aefaf5ace497245ca76c6c9d629ae7bee">send</a>(reply);</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<h2>Connection Engine </h2>
<p>The <code><a class="el" href="classproton_1_1connection__engine.html" title="An interface for connection-oriented IO integration. ">proton::connection_engine</a></code> is an alternative to the container. For simple applications with a single connection, its use is about the same as the the <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links. ">proton::container</a></code>, but it allows more flexibility for multi-threaded applications or applications with unusual IO requirements.</p>
<p>We'll look at the <a class="el" href="engine_2helloworld_8cpp-example.html">engine/helloworld.cpp</a> example step-by-step to see how it differs from the container <a class="el" href="helloworld_8cpp-example.html">helloworld.cpp</a> version.</p>
<p>First we include the <code><a class="el" href="classproton_1_1io_1_1socket__engine.html" title="A connection_engine for socket-based IO. ">proton::io::socket_engine</a></code> class, which is a <code><a class="el" href="classproton_1_1connection__engine.html" title="An interface for connection-oriented IO integration. ">proton::connection_engine</a></code> that uses socket IO.</p>
<p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;proton/io.hpp&quot;</span></div>
</div><!-- fragment --></p>
<p>Our <code>hello_world</code> class differs only in the <code>on_start()</code> method. Instead of calling <code>container.connect()</code>, we simply call <code>proton::connection::open</code> to open the engine's' connection:</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> on_start(<a class="code" href="classproton_1_1event.html">proton::event</a> &amp;e) {</div>
<div class="line">        e.<a class="code" href="classproton_1_1event.html#a30da3a4aab03af60b45861d83f49ca1b">connection</a>().open();</div>
<div class="line">        e.<a class="code" href="classproton_1_1event.html#a30da3a4aab03af60b45861d83f49ca1b">connection</a>().<a class="code" href="classproton_1_1connection.html#af1fb4d28f91a33fb7c8a73a4083f6745">open_receiver</a>(address_);</div>
<div class="line">        e.<a class="code" href="classproton_1_1event.html#a30da3a4aab03af60b45861d83f49ca1b">connection</a>().<a class="code" href="classproton_1_1connection.html#a7ebd6d1b79102078ccdb1e07b1cd90f7">open_sender</a>(address_);</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>Our <code>main</code> function only differs in that it creates and runs a <code>socket_engine</code> instead of a <code>container</code>.</p>
<p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code" href="classproton_1_1url.html">proton::url</a> url(argc &gt; 1 ? argv[1] : <span class="stringliteral">&quot;127.0.0.1:5672/examples&quot;</span>);</div>
<div class="line"></div>
<div class="line">        hello_world hw(url.<a class="code" href="classproton_1_1url.html#a9b67b266207227062c7a2961ef85293a">path</a>());</div>
<div class="line">        <a class="code" href="classproton_1_1io_1_1socket__engine.html">proton::io::socket_engine</a>(url, hw).<a class="code" href="classproton_1_1io_1_1socket__engine.html#a13a43e6d814de94978c515cb084873b1">run</a>();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
