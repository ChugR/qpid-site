<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Qpid Proton C++ API: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Qpid Proton C++ API
   &#160;<span id="projectnumber">0.12.2</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_mainpage.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the C++ API for the Proton AMQP protocol engine. It allows you to write client and server applications that send and receive AMQP messages.</p>
<p>The best way to start is with the <a class="el" href="tutorial.html">tutorial</a>.</p>
<h2>An overview of the AMQP model</h2>
<p>Messages are transferred between connected peers over <em>links</em>. The sending end of a link is a <code><a class="el" href="classproton_1_1sender.html" title="A link for sending messages.">proton::sender</a></code>, and the receiving end is a <code><a class="el" href="classproton_1_1receiver.html" title="A link for receiving messages.">proton::receiver</a></code>. Links have named 'source' and 'target' addresses. See "Sources and Targets" below for more information.</p>
<p>Links are grouped in a <code><a class="el" href="classproton_1_1session.html" title="A container of links.">proton::session</a></code>. Messages for links in the same session are sent sequentially. Messages on different sessions can be interleaved, so a large message being sent on one session does not block messages being sent on other sessions.</p>
<p>Sessions are created over a <code><a class="el" href="classproton_1_1connection.html" title="A connection to a remote AMQP peer.">proton::connection</a></code>, which represents the network connection. You can create links directly on a connection using its default session if you don't need multiple sessions.</p>
<p><code><a class="el" href="classproton_1_1message.html" title="An AMQP message.">proton::message</a></code> represents the message: the body (content), headers, annotations, and so on. A <code><a class="el" href="classproton_1_1delivery.html" title="A message transfer.">proton::delivery</a></code> represents the act of transferring a message over a link. The receiver acknowledges the delivery by accepting or rejecting it. The delivery is <em>settled</em> when both ends are done with it. Different settlement methods give different levels of reliability: <em>at-most-once</em>, <em>at-least-once</em>, and <em>exactly-once</em>. See "Delivery Guarantees" below for details.</p>
<h2>Sources and targets</h2>
<p>Every link has two addresses, <em>source</em> and <em>target</em>. The most common pattern for using these addresses is as follows:</p>
<p>When a client creates a <em>receiver</em> link, it sets the <em>source</em> address. This means "I want to receive messages from this source." This is often referred to as "subscribing" to the source. When a client creates a <em>sender</em> link, it sets the <em>target</em> address. This means "I want to send to this target."</p>
<p>In the case of a broker, the source or target usually refers to a queue or topic. In general they can refer to any AMQP-capable node.</p>
<p>In the <em>request-response</em> pattern, a request message carries a <em>reply-to</em> address for the response message. This can be any AMQP address, but it is often useful to create a temporary address for just the response message.</p>
<p>The most common approach is for the client to create a <em>receiver</em> for the response with the <em>dynamic</em> flag set. This asks the server to generate a unique <em>source</em> address automatically and discard it when the link closes. The client uses this "dynamic" source address as the reply-to when it sends the request, and the response is delivered to the client's dynamic receiver.</p>
<p>In the case of a broker, a dynamic address usually corresponds to a temporary queue, but any AMQP request-response server can use this technique. The <a class="el" href="server_direct_8cpp-example.html">server_direct.cpp</a> example illustrates how to implement a queueless request-response server.</p>
<h2>Anatomy of a Proton application</h2>
<p>To send AMQP commands, call methods on classes like <code><a class="el" href="classproton_1_1connection.html" title="A connection to a remote AMQP peer.">proton::connection</a></code>, <code><a class="el" href="classproton_1_1sender.html" title="A link for sending messages.">proton::sender</a></code>, <code><a class="el" href="classproton_1_1receiver.html" title="A link for receiving messages.">proton::receiver</a></code>, or <code><a class="el" href="classproton_1_1delivery.html" title="A message transfer.">proton::delivery</a></code>. To handle incoming commands, implement the <code><a class="el" href="classproton_1_1handler.html" title="Callback functions for handling proton events.">proton::handler</a></code> interface. The handler receives calls like <code>on_message</code> (a message is received), <code>on_link_open</code> (a link is opened), and <code>on_sendable</code> (a link is ready to send messages).</p>
<p>Messages are represented by <code><a class="el" href="classproton_1_1message.html" title="An AMQP message.">proton::message</a></code>. AMQP defines a type encoding that you can use for interoperability, but you can also use any encoding you wish and pass binary data as the <code><a class="el" href="classproton_1_1message.html#adec309c753bff891f9837bd9977b8440" title="Set the body, equivalent to body() = v.">proton::message::body</a></code>. <code><a class="el" href="classproton_1_1value.html" title="A holder for an AMQP value.">proton::value</a></code> and <code><a class="el" href="classproton_1_1scalar.html" title="A holder for an instance of any scalar AMQP type.">proton::scalar</a></code> provide conversion between AMQP and C++ data types.</p>
<p>There are two alternative ways to manage handlers and AMQP objects, the <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links.">proton::container</a></code> and the <code><a class="el" href="classproton_1_1connection__engine.html" title="An interface for connection-oriented IO integration.">proton::connection_engine</a></code>. You can code your application so that it can be run with either. Say you find the <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links.">proton::container</a></code> easier to get started but later need more flexibility. You can switch to the <code><a class="el" href="classproton_1_1connection__engine.html" title="An interface for connection-oriented IO integration.">proton::connection_engine</a></code> with little or no change to your handlers.</p>
<h3>proton::container</h3>
<p><code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links.">proton::container</a></code> is a <em>reactor</em> framework that manages multiple connections and dispatches events to handlers. You implement <code><a class="el" href="classproton_1_1handler.html" title="Callback functions for handling proton events.">proton::handler</a></code> with your logic to react to events, and register it with the container. The container lets you open multiple connections and links, receive incoming connections and links, and send, receive, and acknowledge messages.</p>
<p>The reactor handles IO for multiple connections using sockets and <code>poll</code>. It dispatches events to your handlers in a single thread, where you call <code><a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1" title="Start processing events.">proton::container::run</a></code>. The container is not thread-safe: once it is running you can only operate on Proton objects from your handler methods.</p>
<h3>proton::connection_engine</h3>
<p><code><a class="el" href="classproton_1_1connection__engine.html" title="An interface for connection-oriented IO integration.">proton::connection_engine</a></code> dispatches events for a <em>single connection</em>. The subclass <code><a class="el" href="classproton_1_1io_1_1socket__engine.html" title="A connection_engine for socket-based IO.">proton::io::socket_engine</a></code> does socket-based IO. An application with a single connection is just like using <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links.">proton::container</a></code> except you attach your handler to a <code><a class="el" href="classproton_1_1io_1_1socket__engine.html" title="A connection_engine for socket-based IO.">proton::io::socket_engine</a></code> instead. You can compare examples, such as <a class="el" href="helloworld_8cpp-example.html">helloworld.cpp</a> and <a class="el" href="engine_2helloworld_8cpp-example.html">engine/helloworld.cpp</a>.</p>
<p>Now consider multiple connections. <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links.">proton::container</a></code> is easy to use but restricted to a single thread. <code><a class="el" href="classproton_1_1connection__engine.html" title="An interface for connection-oriented IO integration.">proton::connection_engine</a></code> is not thread-safe either, but <em>each engine is independent</em>. You can process different connections in different threads, or use a thread pool to process a dynamic set of connections.</p>
<p>The engine does not provide built-in polling and listening like the <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, and links.">proton::container</a></code>, but you can drive engines using any polling or threading strategy and any IO library (for example, epoll, kqueue, solaris completion ports, IOCP proactor, boost::asio, libevent, etc.) This can be important for optimizing performance or supporting diverse platforms. The example <a class="el" href="engine_2broker_8cpp-example.html">engine/broker.cpp</a> shows a broker using sockets and poll, but you can see how the code could be adapted.</p>
<p><code><a class="el" href="classproton_1_1connection__engine.html" title="An interface for connection-oriented IO integration.">proton::connection_engine</a></code> also does not dictate the IO mechanism, but it is an abstract class. <code>proton::socket_engine</code> provides ready-made socket-based IO, but you can write your own subclass with any IO code. Just override the <code>io_read</code>, <code>io_write</code> and <code>io_close</code> methods. For example, the proton test suite implements an in-memory connection using <code>std::deque</code> for test purposes.</p>
<h2>Delivery guarantees</h2>
<p>For <em>at-most-once</em>, the sender settles the message as soon as it sends it. If the connection is lost before the message is received by the receiver, the message will not be delivered.</p>
<p>For <em>at-least-once</em>, the receiver accepts and settles the message on receipt. If the connection is lost before the sender is informed of the settlement, then the delivery is considered in-doubt and should be retried. This will ensure it eventually gets delivered (provided of course the connection and link can be reestablished). It may mean that it is delivered multiple times though.</p>
<p>Finally, for <em>exactly-once</em>, the receiver accepts the message but doesn't settle it. The sender settles once it is aware that the receiver accepted it. In this way the receiver retains knowledge of an accepted message until it is sure the sender knows it has been accepted. If the connection is lost before settlement, the receiver informs the sender of all the unsettled deliveries it knows about, and from this the sender can deduce which need to be redelivered. The sender likewise informs the receiver which deliveries it knows about, from which the receiver can deduce which have already been settled. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
